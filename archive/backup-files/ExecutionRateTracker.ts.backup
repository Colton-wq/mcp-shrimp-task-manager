import { z } from "zod";

/**
 * æ‰§è¡Œç‡ç»Ÿè®¡å·¥å…· - ä¸“é—¨ç”¨äºæµ‹é‡ AI å·¥å…·è°ƒç”¨æ‰§è¡Œç‡
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. è·Ÿè¸ªå·¥å…·è°ƒç”¨çš„å‘èµ·å’Œæ‰§è¡Œæƒ…å†µ
 * 2. ç»Ÿè®¡æ‰§è¡Œç‡å’ŒæˆåŠŸç‡
 * 3. åˆ†ææ‰§è¡Œæ¨¡å¼å’Œå¤±è´¥åŸå› 
 * 4. æä¾› A/B æµ‹è¯•æ”¯æŒ
 */

// æ‰§è¡ŒçŠ¶æ€æšä¸¾
enum ExecutionStatus {
  INITIATED = "initiated",      // å·¥å…·è°ƒç”¨å·²å‘èµ·
  EXECUTED = "executed",        // å·¥å…·è°ƒç”¨å·²æ‰§è¡Œ
  SKIPPED = "skipped",         // å·¥å…·è°ƒç”¨è¢«è·³è¿‡
  FAILED = "failed",           // å·¥å…·è°ƒç”¨æ‰§è¡Œå¤±è´¥
  TIMEOUT = "timeout"          // å·¥å…·è°ƒç”¨è¶…æ—¶
}

// è§¦å‘å™¨ç±»å‹
enum TriggerType {
  LEGACY = "legacy",           // æ—§ç‰ˆè§¦å‘å™¨
  ENHANCED = "enhanced",       // å¢å¼ºç‰ˆè§¦å‘å™¨
  DIRECT_INJECTION = "direct", // ç›´æ¥æ³¨å…¥è§¦å‘å™¨
  CONTEXT_AWARE = "context"    // ä¸Šä¸‹æ–‡æ„ŸçŸ¥è§¦å‘å™¨
}

// æ‰§è¡Œè®°å½•æ¥å£
interface ExecutionRecord {
  id: string;
  timestamp: number;
  toolName: string;
  triggerType: TriggerType;
  status: ExecutionStatus;
  responseTime?: number;
  errorMessage?: string;
  context: {
    problemType: string;
    errorCount: number;
    urgencyLevel: string;
    aiResistanceLevel: string;
  };
  metadata: {
    instructionLength: number;
    triggerCount: number;
    hasForceLanguage: boolean;
    hasProhibitions: boolean;
  };
}

// æ‰§è¡Œç‡ç»Ÿè®¡æ¥å£
interface ExecutionRateStats {
  totalInstructions: number;
  totalExecutions: number;
  executionRate: number;
  successRate: number;
  averageResponseTime: number;
  byTriggerType: Record<TriggerType, {
    instructions: number;
    executions: number;
    rate: number;
  }>;
  byProblemType: Record<string, {
    instructions: number;
    executions: number;
    rate: number;
  }>;
  failureReasons: Record<string, number>;
  improvementTrend: "improving" | "stable" | "declining";
}

// A/B æµ‹è¯•ç»“æœæ¥å£
interface ABTestResult {
  testId: string;
  variantA: {
    name: string;
    triggerType: TriggerType;
    executionRate: number;
    sampleSize: number;
  };
  variantB: {
    name: string;
    triggerType: TriggerType;
    executionRate: number;
    sampleSize: number;
  };
  improvement: number;
  confidence: number;
  isSignificant: boolean;
  recommendation: string;
}

/**
 * æ‰§è¡Œç‡ç»Ÿè®¡å·¥å…·ç±»
 */
export class ExecutionRateTracker {
  private static instance: ExecutionRateTracker;
  private records: ExecutionRecord[] = [];
  private activeInstructions = new Map<string, {
    timestamp: number;
    toolName: string;
    triggerType: TriggerType;
    context: ExecutionRecord['context'];
    metadata: ExecutionRecord['metadata'];
  }>();

  private constructor() {
    // ç§æœ‰æ„é€ å‡½æ•°ï¼Œå®ç°å•ä¾‹æ¨¡å¼
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): ExecutionRateTracker {
    if (!ExecutionRateTracker.instance) {
      ExecutionRateTracker.instance = new ExecutionRateTracker();
    }
    return ExecutionRateTracker.instance;
  }

  /**
   * è®°å½•å·¥å…·è°ƒç”¨æŒ‡ä»¤å‘èµ·
   */
  recordInstruction(
    instructionId: string,
    toolName: string,
    triggerType: TriggerType,
    context: {
      problemType: string;
      errorCount: number;
      urgencyLevel: string;
      aiResistanceLevel: string;
    },
    metadata: {
      instructionLength: number;
      triggerCount: number;
      hasForceLanguage: boolean;
      hasProhibitions: boolean;
    }
  ): void {
    const timestamp = Date.now();
    
    // è®°å½•æ´»åŠ¨æŒ‡ä»¤
    this.activeInstructions.set(instructionId, {
      timestamp,
      toolName,
      triggerType,
      context,
      metadata
    });

    // åˆ›å»ºåˆå§‹è®°å½•
    const record: ExecutionRecord = {
      id: instructionId,
      timestamp,
      toolName,
      triggerType,
      status: ExecutionStatus.INITIATED,
      context,
      metadata
    };

    this.records.push(record);
    console.log(`ğŸ“Š ExecutionRateTracker: è®°å½•æŒ‡ä»¤å‘èµ· ${instructionId} (${toolName})`);
  }

  /**
   * è®°å½•å·¥å…·è°ƒç”¨æ‰§è¡Œ
   */
  recordExecution(
    instructionId: string,
    status: ExecutionStatus,
    responseTime?: number,
    errorMessage?: string
  ): void {
    const instruction = this.activeInstructions.get(instructionId);
    if (!instruction) {
      console.warn(`âš ï¸ ExecutionRateTracker: æœªæ‰¾åˆ°æŒ‡ä»¤ ${instructionId}`);
      return;
    }

    // æ›´æ–°è®°å½•
    const recordIndex = this.records.findIndex(r => r.id === instructionId);
    if (recordIndex !== -1) {
      this.records[recordIndex].status = status;
      this.records[recordIndex].responseTime = responseTime;
      this.records[recordIndex].errorMessage = errorMessage;
    }

    // æ¸…ç†æ´»åŠ¨æŒ‡ä»¤
    this.activeInstructions.delete(instructionId);

    console.log(`ğŸ“Š ExecutionRateTracker: è®°å½•æ‰§è¡Œç»“æœ ${instructionId} (${status})`);
  }

  /**
   * è‡ªåŠ¨æ£€æµ‹å·¥å…·è°ƒç”¨è¶…æ—¶
   */
  checkTimeouts(timeoutMs: number = 60000): void {
    const now = Date.now();
    const timeoutInstructions: string[] = [];

    for (const [instructionId, instruction] of this.activeInstructions) {
      if (now - instruction.timestamp > timeoutMs) {
        this.recordExecution(instructionId, ExecutionStatus.TIMEOUT);
        timeoutInstructions.push(instructionId);
      }
    }

    if (timeoutInstructions.length > 0) {
      console.log(`â° ExecutionRateTracker: æ£€æµ‹åˆ° ${timeoutInstructions.length} ä¸ªè¶…æ—¶æŒ‡ä»¤`);
    }
  }

  /**
   * è·å–æ‰§è¡Œç‡ç»Ÿè®¡
   */
  getExecutionRateStats(timeRangeMs?: number): ExecutionRateStats {
    const now = Date.now();
    const relevantRecords = timeRangeMs 
      ? this.records.filter(r => now - r.timestamp <= timeRangeMs)
      : this.records;

    if (relevantRecords.length === 0) {
      return this.getEmptyStats();
    }

    const totalInstructions = relevantRecords.length;
    const executedRecords = relevantRecords.filter(r => 
      r.status === ExecutionStatus.EXECUTED
    );
    const totalExecutions = executedRecords.length;
    const executionRate = totalExecutions / totalInstructions;

    const successfulRecords = executedRecords.filter(r => !r.errorMessage);
    const successRate = successfulRecords.length / totalExecutions;

    const averageResponseTime = executedRecords
      .filter(r => r.responseTime)
      .reduce((sum, r) => sum + (r.responseTime || 0), 0) / executedRecords.length;

    // æŒ‰è§¦å‘å™¨ç±»å‹ç»Ÿè®¡
    const byTriggerType = this.calculateByTriggerType(relevantRecords);

    // æŒ‰é—®é¢˜ç±»å‹ç»Ÿè®¡
    const byProblemType = this.calculateByProblemType(relevantRecords);

    // å¤±è´¥åŸå› ç»Ÿè®¡
    const failureReasons = this.calculateFailureReasons(relevantRecords);

    // æ”¹è¿›è¶‹åŠ¿åˆ†æ
    const improvementTrend = this.calculateImprovementTrend(relevantRecords);

    return {
      totalInstructions,
      totalExecutions,
      executionRate,
      successRate,
      averageResponseTime,
      byTriggerType,
      byProblemType,
      failureReasons,
      improvementTrend
    };
  }

  /**
   * æŒ‰è§¦å‘å™¨ç±»å‹è®¡ç®—ç»Ÿè®¡
   */
  private calculateByTriggerType(records: ExecutionRecord[]): Record<TriggerType, any> {
    const stats: Record<TriggerType, any> = {
      [TriggerType.LEGACY]: { instructions: 0, executions: 0, rate: 0 },
      [TriggerType.ENHANCED]: { instructions: 0, executions: 0, rate: 0 },
      [TriggerType.DIRECT_INJECTION]: { instructions: 0, executions: 0, rate: 0 },
      [TriggerType.CONTEXT_AWARE]: { instructions: 0, executions: 0, rate: 0 }
    };

    for (const record of records) {
      stats[record.triggerType].instructions++;
      if (record.status === ExecutionStatus.EXECUTED) {
        stats[record.triggerType].executions++;
      }
    }

    // è®¡ç®—æ‰§è¡Œç‡
    for (const triggerType of Object.keys(stats)) {
      const stat = stats[triggerType as TriggerType];
      stat.rate = stat.instructions > 0 ? stat.executions / stat.instructions : 0;
    }

    return stats;
  }

  /**
   * æŒ‰é—®é¢˜ç±»å‹è®¡ç®—ç»Ÿè®¡
   */
  private calculateByProblemType(records: ExecutionRecord[]): Record<string, any> {
    const stats: Record<string, any> = {};

    for (const record of records) {
      const problemType = record.context.problemType;
      if (!stats[problemType]) {
        stats[problemType] = { instructions: 0, executions: 0, rate: 0 };
      }

      stats[problemType].instructions++;
      if (record.status === ExecutionStatus.EXECUTED) {
        stats[problemType].executions++;
      }
    }

    // è®¡ç®—æ‰§è¡Œç‡
    for (const problemType of Object.keys(stats)) {
      const stat = stats[problemType];
      stat.rate = stat.instructions > 0 ? stat.executions / stat.instructions : 0;
    }

    return stats;
  }

  /**
   * è®¡ç®—å¤±è´¥åŸå› ç»Ÿè®¡
   */
  private calculateFailureReasons(records: ExecutionRecord[]): Record<string, number> {
    const reasons: Record<string, number> = {};

    for (const record of records) {
      if (record.status === ExecutionStatus.SKIPPED) {
        reasons["å·¥å…·è°ƒç”¨è¢«è·³è¿‡"] = (reasons["å·¥å…·è°ƒç”¨è¢«è·³è¿‡"] || 0) + 1;
      } else if (record.status === ExecutionStatus.FAILED && record.errorMessage) {
        const reason = this.categorizeError(record.errorMessage);
        reasons[reason] = (reasons[reason] || 0) + 1;
      } else if (record.status === ExecutionStatus.TIMEOUT) {
        reasons["æ‰§è¡Œè¶…æ—¶"] = (reasons["æ‰§è¡Œè¶…æ—¶"] || 0) + 1;
      }
    }

    return reasons;
  }

  /**
   * åˆ†ç±»é”™è¯¯ä¿¡æ¯
   */
  private categorizeError(errorMessage: string): string {
    const lowerError = errorMessage.toLowerCase();
    
    if (lowerError.includes("parameter") || lowerError.includes("argument")) {
      return "å‚æ•°é”™è¯¯";
    } else if (lowerError.includes("timeout") || lowerError.includes("time")) {
      return "è¶…æ—¶é”™è¯¯";
    } else if (lowerError.includes("network") || lowerError.includes("connection")) {
      return "ç½‘ç»œé”™è¯¯";
    } else if (lowerError.includes("permission") || lowerError.includes("access")) {
      return "æƒé™é”™è¯¯";
    } else {
      return "å…¶ä»–é”™è¯¯";
    }
  }

  /**
   * è®¡ç®—æ”¹è¿›è¶‹åŠ¿
   */
  private calculateImprovementTrend(records: ExecutionRecord[]): "improving" | "stable" | "declining" {
    if (records.length < 10) {
      return "stable";
    }

    // å°†è®°å½•åˆ†ä¸ºå‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†
    const midPoint = Math.floor(records.length / 2);
    const firstHalf = records.slice(0, midPoint);
    const secondHalf = records.slice(midPoint);

    const firstHalfRate = firstHalf.filter(r => r.status === ExecutionStatus.EXECUTED).length / firstHalf.length;
    const secondHalfRate = secondHalf.filter(r => r.status === ExecutionStatus.EXECUTED).length / secondHalf.length;

    const improvement = secondHalfRate - firstHalfRate;

    if (improvement > 0.05) {
      return "improving";
    } else if (improvement < -0.05) {
      return "declining";
    } else {
      return "stable";
    }
  }

  /**
   * æ‰§è¡Œ A/B æµ‹è¯•
   */
  performABTest(
    testId: string,
    variantAType: TriggerType,
    variantBType: TriggerType,
    timeRangeMs: number = 24 * 60 * 60 * 1000 // é»˜è®¤24å°æ—¶
  ): ABTestResult {
    const now = Date.now();
    const testRecords = this.records.filter(r => 
      now - r.timestamp <= timeRangeMs &&
      (r.triggerType === variantAType || r.triggerType === variantBType)
    );

    const variantARecords = testRecords.filter(r => r.triggerType === variantAType);
    const variantBRecords = testRecords.filter(r => r.triggerType === variantBType);

    const variantARate = variantARecords.length > 0 
      ? variantARecords.filter(r => r.status === ExecutionStatus.EXECUTED).length / variantARecords.length
      : 0;

    const variantBRate = variantBRecords.length > 0
      ? variantBRecords.filter(r => r.status === ExecutionStatus.EXECUTED).length / variantBRecords.length
      : 0;

    const improvement = ((variantBRate - variantARate) / variantARate) * 100;
    const confidence = this.calculateConfidence(variantARecords.length, variantBRecords.length, variantARate, variantBRate);
    const isSignificant = confidence > 95;

    let recommendation: string;
    if (isSignificant) {
      if (improvement > 10) {
        recommendation = `å¼ºçƒˆæ¨èä½¿ç”¨ ${variantBType}ï¼Œæ‰§è¡Œç‡æå‡ ${improvement.toFixed(1)}%`;
      } else if (improvement > 5) {
        recommendation = `æ¨èä½¿ç”¨ ${variantBType}ï¼Œæ‰§è¡Œç‡æœ‰æ‰€æå‡`;
      } else if (improvement < -10) {
        recommendation = `ç»§ç»­ä½¿ç”¨ ${variantAType}ï¼Œ${variantBType} è¡¨ç°è¾ƒå·®`;
      } else {
        recommendation = `ä¸¤ç§è§¦å‘å™¨è¡¨ç°ç›¸è¿‘ï¼Œå¯ç»§ç»­ä½¿ç”¨ ${variantAType}`;
      }
    } else {
      recommendation = "æ ·æœ¬é‡ä¸è¶³ï¼Œéœ€è¦æ›´å¤šæ•°æ®æ‰èƒ½å¾—å‡ºç»“è®º";
    }

    return {
      testId,
      variantA: {
        name: variantAType,
        triggerType: variantAType,
        executionRate: variantARate,
        sampleSize: variantARecords.length
      },
      variantB: {
        name: variantBType,
        triggerType: variantBType,
        executionRate: variantBRate,
        sampleSize: variantBRecords.length
      },
      improvement,
      confidence,
      isSignificant,
      recommendation
    };
  }

  /**
   * è®¡ç®—ç»Ÿè®¡ç½®ä¿¡åº¦
   */
  private calculateConfidence(sampleA: number, sampleB: number, rateA: number, rateB: number): number {
    if (sampleA < 10 || sampleB < 10) {
      return 0;
    }

    // ç®€åŒ–çš„ç½®ä¿¡åº¦è®¡ç®—
    const pooledRate = (rateA * sampleA + rateB * sampleB) / (sampleA + sampleB);
    const standardError = Math.sqrt(pooledRate * (1 - pooledRate) * (1/sampleA + 1/sampleB));
    const zScore = Math.abs(rateA - rateB) / standardError;

    // è½¬æ¢ä¸ºç½®ä¿¡åº¦ç™¾åˆ†æ¯”ï¼ˆç®€åŒ–ç‰ˆï¼‰
    if (zScore > 2.58) return 99;
    if (zScore > 1.96) return 95;
    if (zScore > 1.64) return 90;
    if (zScore > 1.28) return 80;
    return Math.max(50, 50 + zScore * 15);
  }

  /**
   * è·å–ç©ºç»Ÿè®¡å¯¹è±¡
   */
  private getEmptyStats(): ExecutionRateStats {
    return {
      totalInstructions: 0,
      totalExecutions: 0,
      executionRate: 0,
      successRate: 0,
      averageResponseTime: 0,
      byTriggerType: {
        [TriggerType.LEGACY]: { instructions: 0, executions: 0, rate: 0 },
        [TriggerType.ENHANCED]: { instructions: 0, executions: 0, rate: 0 },
        [TriggerType.DIRECT_INJECTION]: { instructions: 0, executions: 0, rate: 0 },
        [TriggerType.CONTEXT_AWARE]: { instructions: 0, executions: 0, rate: 0 }
      },
      byProblemType: {},
      failureReasons: {},
      improvementTrend: "stable"
    };
  }

  /**
   * å¯¼å‡ºç»Ÿè®¡æ•°æ®
   */
  exportData(): {
    records: ExecutionRecord[];
    summary: ExecutionRateStats;
    exportTime: number;
  } {
    return {
      records: [...this.records],
      summary: this.getExecutionRateStats(),
      exportTime: Date.now()
    };
  }

  /**
   * æ¸…ç†æ—§æ•°æ®
   */
  cleanup(retentionDays: number = 7): void {
    const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);
    const initialCount = this.records.length;
    
    this.records = this.records.filter(r => r.timestamp > cutoffTime);
    
    const removedCount = initialCount - this.records.length;
    if (removedCount > 0) {
      console.log(`ğŸ§¹ ExecutionRateTracker: æ¸…ç†äº† ${removedCount} æ¡æ—§è®°å½•`);
    }
  }
}

/**
 * å¯¼å‡ºæšä¸¾å’Œç±»å‹
 */
export { ExecutionStatus, TriggerType };
export type { ExecutionRecord, ExecutionRateStats, ABTestResult };