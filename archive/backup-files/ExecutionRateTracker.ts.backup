import { z } from "zod";

/**
 * 执行率统计工具 - 专门用于测量 AI 工具调用执行率
 * 
 * 核心功能：
 * 1. 跟踪工具调用的发起和执行情况
 * 2. 统计执行率和成功率
 * 3. 分析执行模式和失败原因
 * 4. 提供 A/B 测试支持
 */

// 执行状态枚举
enum ExecutionStatus {
  INITIATED = "initiated",      // 工具调用已发起
  EXECUTED = "executed",        // 工具调用已执行
  SKIPPED = "skipped",         // 工具调用被跳过
  FAILED = "failed",           // 工具调用执行失败
  TIMEOUT = "timeout"          // 工具调用超时
}

// 触发器类型
enum TriggerType {
  LEGACY = "legacy",           // 旧版触发器
  ENHANCED = "enhanced",       // 增强版触发器
  DIRECT_INJECTION = "direct", // 直接注入触发器
  CONTEXT_AWARE = "context"    // 上下文感知触发器
}

// 执行记录接口
interface ExecutionRecord {
  id: string;
  timestamp: number;
  toolName: string;
  triggerType: TriggerType;
  status: ExecutionStatus;
  responseTime?: number;
  errorMessage?: string;
  context: {
    problemType: string;
    errorCount: number;
    urgencyLevel: string;
    aiResistanceLevel: string;
  };
  metadata: {
    instructionLength: number;
    triggerCount: number;
    hasForceLanguage: boolean;
    hasProhibitions: boolean;
  };
}

// 执行率统计接口
interface ExecutionRateStats {
  totalInstructions: number;
  totalExecutions: number;
  executionRate: number;
  successRate: number;
  averageResponseTime: number;
  byTriggerType: Record<TriggerType, {
    instructions: number;
    executions: number;
    rate: number;
  }>;
  byProblemType: Record<string, {
    instructions: number;
    executions: number;
    rate: number;
  }>;
  failureReasons: Record<string, number>;
  improvementTrend: "improving" | "stable" | "declining";
}

// A/B 测试结果接口
interface ABTestResult {
  testId: string;
  variantA: {
    name: string;
    triggerType: TriggerType;
    executionRate: number;
    sampleSize: number;
  };
  variantB: {
    name: string;
    triggerType: TriggerType;
    executionRate: number;
    sampleSize: number;
  };
  improvement: number;
  confidence: number;
  isSignificant: boolean;
  recommendation: string;
}

/**
 * 执行率统计工具类
 */
export class ExecutionRateTracker {
  private static instance: ExecutionRateTracker;
  private records: ExecutionRecord[] = [];
  private activeInstructions = new Map<string, {
    timestamp: number;
    toolName: string;
    triggerType: TriggerType;
    context: ExecutionRecord['context'];
    metadata: ExecutionRecord['metadata'];
  }>();

  private constructor() {
    // 私有构造函数，实现单例模式
  }

  /**
   * 获取单例实例
   */
  static getInstance(): ExecutionRateTracker {
    if (!ExecutionRateTracker.instance) {
      ExecutionRateTracker.instance = new ExecutionRateTracker();
    }
    return ExecutionRateTracker.instance;
  }

  /**
   * 记录工具调用指令发起
   */
  recordInstruction(
    instructionId: string,
    toolName: string,
    triggerType: TriggerType,
    context: {
      problemType: string;
      errorCount: number;
      urgencyLevel: string;
      aiResistanceLevel: string;
    },
    metadata: {
      instructionLength: number;
      triggerCount: number;
      hasForceLanguage: boolean;
      hasProhibitions: boolean;
    }
  ): void {
    const timestamp = Date.now();
    
    // 记录活动指令
    this.activeInstructions.set(instructionId, {
      timestamp,
      toolName,
      triggerType,
      context,
      metadata
    });

    // 创建初始记录
    const record: ExecutionRecord = {
      id: instructionId,
      timestamp,
      toolName,
      triggerType,
      status: ExecutionStatus.INITIATED,
      context,
      metadata
    };

    this.records.push(record);
    console.log(`📊 ExecutionRateTracker: 记录指令发起 ${instructionId} (${toolName})`);
  }

  /**
   * 记录工具调用执行
   */
  recordExecution(
    instructionId: string,
    status: ExecutionStatus,
    responseTime?: number,
    errorMessage?: string
  ): void {
    const instruction = this.activeInstructions.get(instructionId);
    if (!instruction) {
      console.warn(`⚠️ ExecutionRateTracker: 未找到指令 ${instructionId}`);
      return;
    }

    // 更新记录
    const recordIndex = this.records.findIndex(r => r.id === instructionId);
    if (recordIndex !== -1) {
      this.records[recordIndex].status = status;
      this.records[recordIndex].responseTime = responseTime;
      this.records[recordIndex].errorMessage = errorMessage;
    }

    // 清理活动指令
    this.activeInstructions.delete(instructionId);

    console.log(`📊 ExecutionRateTracker: 记录执行结果 ${instructionId} (${status})`);
  }

  /**
   * 自动检测工具调用超时
   */
  checkTimeouts(timeoutMs: number = 60000): void {
    const now = Date.now();
    const timeoutInstructions: string[] = [];

    for (const [instructionId, instruction] of this.activeInstructions) {
      if (now - instruction.timestamp > timeoutMs) {
        this.recordExecution(instructionId, ExecutionStatus.TIMEOUT);
        timeoutInstructions.push(instructionId);
      }
    }

    if (timeoutInstructions.length > 0) {
      console.log(`⏰ ExecutionRateTracker: 检测到 ${timeoutInstructions.length} 个超时指令`);
    }
  }

  /**
   * 获取执行率统计
   */
  getExecutionRateStats(timeRangeMs?: number): ExecutionRateStats {
    const now = Date.now();
    const relevantRecords = timeRangeMs 
      ? this.records.filter(r => now - r.timestamp <= timeRangeMs)
      : this.records;

    if (relevantRecords.length === 0) {
      return this.getEmptyStats();
    }

    const totalInstructions = relevantRecords.length;
    const executedRecords = relevantRecords.filter(r => 
      r.status === ExecutionStatus.EXECUTED
    );
    const totalExecutions = executedRecords.length;
    const executionRate = totalExecutions / totalInstructions;

    const successfulRecords = executedRecords.filter(r => !r.errorMessage);
    const successRate = successfulRecords.length / totalExecutions;

    const averageResponseTime = executedRecords
      .filter(r => r.responseTime)
      .reduce((sum, r) => sum + (r.responseTime || 0), 0) / executedRecords.length;

    // 按触发器类型统计
    const byTriggerType = this.calculateByTriggerType(relevantRecords);

    // 按问题类型统计
    const byProblemType = this.calculateByProblemType(relevantRecords);

    // 失败原因统计
    const failureReasons = this.calculateFailureReasons(relevantRecords);

    // 改进趋势分析
    const improvementTrend = this.calculateImprovementTrend(relevantRecords);

    return {
      totalInstructions,
      totalExecutions,
      executionRate,
      successRate,
      averageResponseTime,
      byTriggerType,
      byProblemType,
      failureReasons,
      improvementTrend
    };
  }

  /**
   * 按触发器类型计算统计
   */
  private calculateByTriggerType(records: ExecutionRecord[]): Record<TriggerType, any> {
    const stats: Record<TriggerType, any> = {
      [TriggerType.LEGACY]: { instructions: 0, executions: 0, rate: 0 },
      [TriggerType.ENHANCED]: { instructions: 0, executions: 0, rate: 0 },
      [TriggerType.DIRECT_INJECTION]: { instructions: 0, executions: 0, rate: 0 },
      [TriggerType.CONTEXT_AWARE]: { instructions: 0, executions: 0, rate: 0 }
    };

    for (const record of records) {
      stats[record.triggerType].instructions++;
      if (record.status === ExecutionStatus.EXECUTED) {
        stats[record.triggerType].executions++;
      }
    }

    // 计算执行率
    for (const triggerType of Object.keys(stats)) {
      const stat = stats[triggerType as TriggerType];
      stat.rate = stat.instructions > 0 ? stat.executions / stat.instructions : 0;
    }

    return stats;
  }

  /**
   * 按问题类型计算统计
   */
  private calculateByProblemType(records: ExecutionRecord[]): Record<string, any> {
    const stats: Record<string, any> = {};

    for (const record of records) {
      const problemType = record.context.problemType;
      if (!stats[problemType]) {
        stats[problemType] = { instructions: 0, executions: 0, rate: 0 };
      }

      stats[problemType].instructions++;
      if (record.status === ExecutionStatus.EXECUTED) {
        stats[problemType].executions++;
      }
    }

    // 计算执行率
    for (const problemType of Object.keys(stats)) {
      const stat = stats[problemType];
      stat.rate = stat.instructions > 0 ? stat.executions / stat.instructions : 0;
    }

    return stats;
  }

  /**
   * 计算失败原因统计
   */
  private calculateFailureReasons(records: ExecutionRecord[]): Record<string, number> {
    const reasons: Record<string, number> = {};

    for (const record of records) {
      if (record.status === ExecutionStatus.SKIPPED) {
        reasons["工具调用被跳过"] = (reasons["工具调用被跳过"] || 0) + 1;
      } else if (record.status === ExecutionStatus.FAILED && record.errorMessage) {
        const reason = this.categorizeError(record.errorMessage);
        reasons[reason] = (reasons[reason] || 0) + 1;
      } else if (record.status === ExecutionStatus.TIMEOUT) {
        reasons["执行超时"] = (reasons["执行超时"] || 0) + 1;
      }
    }

    return reasons;
  }

  /**
   * 分类错误信息
   */
  private categorizeError(errorMessage: string): string {
    const lowerError = errorMessage.toLowerCase();
    
    if (lowerError.includes("parameter") || lowerError.includes("argument")) {
      return "参数错误";
    } else if (lowerError.includes("timeout") || lowerError.includes("time")) {
      return "超时错误";
    } else if (lowerError.includes("network") || lowerError.includes("connection")) {
      return "网络错误";
    } else if (lowerError.includes("permission") || lowerError.includes("access")) {
      return "权限错误";
    } else {
      return "其他错误";
    }
  }

  /**
   * 计算改进趋势
   */
  private calculateImprovementTrend(records: ExecutionRecord[]): "improving" | "stable" | "declining" {
    if (records.length < 10) {
      return "stable";
    }

    // 将记录分为前半部分和后半部分
    const midPoint = Math.floor(records.length / 2);
    const firstHalf = records.slice(0, midPoint);
    const secondHalf = records.slice(midPoint);

    const firstHalfRate = firstHalf.filter(r => r.status === ExecutionStatus.EXECUTED).length / firstHalf.length;
    const secondHalfRate = secondHalf.filter(r => r.status === ExecutionStatus.EXECUTED).length / secondHalf.length;

    const improvement = secondHalfRate - firstHalfRate;

    if (improvement > 0.05) {
      return "improving";
    } else if (improvement < -0.05) {
      return "declining";
    } else {
      return "stable";
    }
  }

  /**
   * 执行 A/B 测试
   */
  performABTest(
    testId: string,
    variantAType: TriggerType,
    variantBType: TriggerType,
    timeRangeMs: number = 24 * 60 * 60 * 1000 // 默认24小时
  ): ABTestResult {
    const now = Date.now();
    const testRecords = this.records.filter(r => 
      now - r.timestamp <= timeRangeMs &&
      (r.triggerType === variantAType || r.triggerType === variantBType)
    );

    const variantARecords = testRecords.filter(r => r.triggerType === variantAType);
    const variantBRecords = testRecords.filter(r => r.triggerType === variantBType);

    const variantARate = variantARecords.length > 0 
      ? variantARecords.filter(r => r.status === ExecutionStatus.EXECUTED).length / variantARecords.length
      : 0;

    const variantBRate = variantBRecords.length > 0
      ? variantBRecords.filter(r => r.status === ExecutionStatus.EXECUTED).length / variantBRecords.length
      : 0;

    const improvement = ((variantBRate - variantARate) / variantARate) * 100;
    const confidence = this.calculateConfidence(variantARecords.length, variantBRecords.length, variantARate, variantBRate);
    const isSignificant = confidence > 95;

    let recommendation: string;
    if (isSignificant) {
      if (improvement > 10) {
        recommendation = `强烈推荐使用 ${variantBType}，执行率提升 ${improvement.toFixed(1)}%`;
      } else if (improvement > 5) {
        recommendation = `推荐使用 ${variantBType}，执行率有所提升`;
      } else if (improvement < -10) {
        recommendation = `继续使用 ${variantAType}，${variantBType} 表现较差`;
      } else {
        recommendation = `两种触发器表现相近，可继续使用 ${variantAType}`;
      }
    } else {
      recommendation = "样本量不足，需要更多数据才能得出结论";
    }

    return {
      testId,
      variantA: {
        name: variantAType,
        triggerType: variantAType,
        executionRate: variantARate,
        sampleSize: variantARecords.length
      },
      variantB: {
        name: variantBType,
        triggerType: variantBType,
        executionRate: variantBRate,
        sampleSize: variantBRecords.length
      },
      improvement,
      confidence,
      isSignificant,
      recommendation
    };
  }

  /**
   * 计算统计置信度
   */
  private calculateConfidence(sampleA: number, sampleB: number, rateA: number, rateB: number): number {
    if (sampleA < 10 || sampleB < 10) {
      return 0;
    }

    // 简化的置信度计算
    const pooledRate = (rateA * sampleA + rateB * sampleB) / (sampleA + sampleB);
    const standardError = Math.sqrt(pooledRate * (1 - pooledRate) * (1/sampleA + 1/sampleB));
    const zScore = Math.abs(rateA - rateB) / standardError;

    // 转换为置信度百分比（简化版）
    if (zScore > 2.58) return 99;
    if (zScore > 1.96) return 95;
    if (zScore > 1.64) return 90;
    if (zScore > 1.28) return 80;
    return Math.max(50, 50 + zScore * 15);
  }

  /**
   * 获取空统计对象
   */
  private getEmptyStats(): ExecutionRateStats {
    return {
      totalInstructions: 0,
      totalExecutions: 0,
      executionRate: 0,
      successRate: 0,
      averageResponseTime: 0,
      byTriggerType: {
        [TriggerType.LEGACY]: { instructions: 0, executions: 0, rate: 0 },
        [TriggerType.ENHANCED]: { instructions: 0, executions: 0, rate: 0 },
        [TriggerType.DIRECT_INJECTION]: { instructions: 0, executions: 0, rate: 0 },
        [TriggerType.CONTEXT_AWARE]: { instructions: 0, executions: 0, rate: 0 }
      },
      byProblemType: {},
      failureReasons: {},
      improvementTrend: "stable"
    };
  }

  /**
   * 导出统计数据
   */
  exportData(): {
    records: ExecutionRecord[];
    summary: ExecutionRateStats;
    exportTime: number;
  } {
    return {
      records: [...this.records],
      summary: this.getExecutionRateStats(),
      exportTime: Date.now()
    };
  }

  /**
   * 清理旧数据
   */
  cleanup(retentionDays: number = 7): void {
    const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);
    const initialCount = this.records.length;
    
    this.records = this.records.filter(r => r.timestamp > cutoffTime);
    
    const removedCount = initialCount - this.records.length;
    if (removedCount > 0) {
      console.log(`🧹 ExecutionRateTracker: 清理了 ${removedCount} 条旧记录`);
    }
  }
}

/**
 * 导出枚举和类型
 */
export { ExecutionStatus, TriggerType };
export type { ExecutionRecord, ExecutionRateStats, ABTestResult };