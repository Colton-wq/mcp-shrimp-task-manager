import { z } from "zod";
import { UUID_V4_REGEX } from "../../utils/regex.js";
import { getTaskById, getAllTasks } from "../../models/taskModel.js";
import { TaskStatus, Task } from "../../types/index.js";
import { withFileLock } from "../../utils/fileLock.js";
import {
  createSuccessResponse,
  createNotFoundError,
  createValidationError,
  createInternalError,
  createWorkflowResponse,
} from "../../utils/mcpResponse.js";
import { SimpleWorkflowManager } from "../../utils/workflowManager.js";
import { WorkflowStatus } from "../../types/workflow.js";
import { AuditCheckpoint, TaskType } from "../../prompts/generators/executeTask.js";
import * as fs from "fs";
import * as path from "path";
import * as ts from "typescript";

// å¯¼å…¥çœŸå®çš„ä»£ç è´¨é‡æ£€æŸ¥å™¨ - æ¶ˆé™¤è™šå‡å®ç°
// Import real code quality checker - eliminate fake implementations
// æ³¨æ„ï¼šç”±äºè·¯å¾„å¤æ‚æ€§ï¼Œæˆ‘ä»¬å°†ç›´æ¥åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°çœŸå®çš„è´¨é‡æ£€æŸ¥é€»è¾‘
/**
 * çœŸå®çš„ä»£ç è´¨é‡åˆ†æå™¨ - æ¶ˆé™¤è™šå‡å®ç°
 * Real Code Quality Analyzer - Eliminate Fake Implementations
 */
class RealCodeQualityAnalyzer {
  private static instance: RealCodeQualityAnalyzer;

  private readonly qualityThresholds = {
    cyclomaticComplexity: 10,
    cognitiveComplexity: 15,
    linesOfCode: 300,
    maintainabilityIndex: 50,
    eslintErrorsPerFile: 0,
    eslintWarningsPerFile: 5,
  };

  public static getInstance(): RealCodeQualityAnalyzer {
    if (!RealCodeQualityAnalyzer.instance) {
      RealCodeQualityAnalyzer.instance = new RealCodeQualityAnalyzer();
    }
    return RealCodeQualityAnalyzer.instance;
  }

  /**
   * è¿è¡ŒçœŸå®çš„ ESLint åˆ†æ
   */
  public async runESLintAnalysis(filePaths: string[]): Promise<Array<{
    type: 'error' | 'warning';
    file: string;
    line: number;
    column: number;
    message: string;
    rule: string;
  }>> {
    const issues: Array<{
      type: 'error' | 'warning';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
    }> = [];

    try {
      // åŠ¨æ€å¯¼å…¥ ESLint ä»¥é¿å…æ„å»ºæ—¶ä¾èµ–é—®é¢˜
      const { ESLint } = await import('eslint');

      const eslint = new ESLint({
        overrideConfigFile: undefined, // ä½¿ç”¨é¡¹ç›®çš„ ESLint é…ç½®
        fix: false,
        cwd: process.cwd()
      });

      const results = await eslint.lintFiles(filePaths);

      for (const result of results) {
        for (const message of result.messages) {
          issues.push({
            type: message.severity === 2 ? 'error' : 'warning',
            file: result.filePath,
            line: message.line,
            column: message.column,
            message: message.message,
            rule: message.ruleId || 'unknown'
          });
        }
      }
    } catch (error) {
      // å¦‚æœ ESLint ä¸å¯ç”¨ï¼Œè¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
      console.warn('ESLint not available, skipping lint analysis:', error);
    }

    return issues;
  }

  /**
   * è®¡ç®—çœŸå®çš„ä»£ç å¤æ‚åº¦æŒ‡æ ‡
   */
  public async calculateComplexity(filePaths: string[]): Promise<{
    cyclomaticComplexity: number;
    cognitiveComplexity: number;
    linesOfCode: number;
    maintainabilityIndex: number;
  }> {
    let totalCyclomaticComplexity = 0;
    let totalCognitiveComplexity = 0;
    let totalLinesOfCode = 0;
    let functionCount = 0;

    for (const filePath of filePaths) {
      if (!fs.existsSync(filePath) || !filePath.match(/\.(ts|tsx|js|jsx)$/)) {
        continue;
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const sourceFile = ts.createSourceFile(
        filePath,
        content,
        ts.ScriptTarget.Latest,
        true
      );

      // è®¡ç®—è¡Œæ•°ï¼ˆæ’é™¤ç©ºè¡Œå’Œæ³¨é‡Šï¼‰
      const lines = content.split('\n').filter(line =>
        line.trim() !== '' && !line.trim().startsWith('//')
      );
      totalLinesOfCode += lines.length;

      // éå† AST è®¡ç®—å¤æ‚åº¦
      const visitor = (node: ts.Node) => {
        if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) || ts.isArrowFunction(node)) {
          functionCount++;
          totalCyclomaticComplexity += this.calculateCyclomaticComplexity(node);
          totalCognitiveComplexity += this.calculateCognitiveComplexity(node);
        }
        ts.forEachChild(node, visitor);
      };

      visitor(sourceFile);
    }

    // è®¡ç®—å¯ç»´æŠ¤æ€§æŒ‡æ•° - ä½¿ç”¨ Microsoft å…¬å¼
    const avgCyclomaticComplexity = functionCount > 0 ? totalCyclomaticComplexity / functionCount : 0;
    const maintainabilityIndex = Math.max(0,
      171 - 5.2 * Math.log(totalLinesOfCode || 1) -
      0.23 * avgCyclomaticComplexity -
      16.2 * Math.log(totalLinesOfCode || 1)
    );

    return {
      cyclomaticComplexity: avgCyclomaticComplexity,
      cognitiveComplexity: totalCognitiveComplexity / Math.max(functionCount, 1),
      linesOfCode: totalLinesOfCode,
      maintainabilityIndex: Math.round(maintainabilityIndex)
    };
  }

  /**
   * è®¡ç®—å¾ªç¯å¤æ‚åº¦ - åŸºäºå†³ç­–ç‚¹
   */
  private calculateCyclomaticComplexity(node: ts.Node): number {
    let complexity = 1; // åŸºç¡€å¤æ‚åº¦

    const visitor = (child: ts.Node) => {
      // å†³ç­–ç‚¹ï¼šif, while, for, switch case, catch, &&, ||, ?:
      if (ts.isIfStatement(child) ||
          ts.isWhileStatement(child) ||
          ts.isForStatement(child) ||
          ts.isForInStatement(child) ||
          ts.isForOfStatement(child) ||
          ts.isCaseClause(child) ||
          ts.isCatchClause(child) ||
          ts.isConditionalExpression(child)) {
        complexity++;
      }

      // é€»è¾‘è¿ç®—ç¬¦
      if (ts.isBinaryExpression(child)) {
        if (child.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
            child.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
          complexity++;
        }
      }

      ts.forEachChild(child, visitor);
    };

    ts.forEachChild(node, visitor);
    return complexity;
  }

  /**
   * è®¡ç®—è®¤çŸ¥å¤æ‚åº¦ - åŸºäºåµŒå¥—æ·±åº¦
   */
  private calculateCognitiveComplexity(node: ts.Node): number {
    let complexity = 0;

    const visitor = (child: ts.Node, level: number) => {
      if (ts.isIfStatement(child) ||
          ts.isWhileStatement(child) ||
          ts.isForStatement(child) ||
          ts.isSwitchStatement(child)) {
        complexity += 1 + level;
        level++;
      }

      ts.forEachChild(child, (grandChild) => visitor(grandChild, level));
    };

    ts.forEachChild(node, (child) => visitor(child, 0));
    return complexity;
  }

  /**
   * åŸºäºæˆåŠŸ MCP æ¨¡å¼çš„ç»¼åˆä»£ç åˆ†æ - å‚è€ƒ code-auditor-mcp
   * Comprehensive code analysis based on successful MCP patterns
   */
  public async analyzeCodeQuality(filePaths: string[]): Promise<{
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>;
    metrics: {
      cyclomaticComplexity: number;
      cognitiveComplexity: number;
      linesOfCode: number;
      maintainabilityIndex: number;
      classCount: number;
      methodCount: number;
    };
    score: number;
  }> {
    const violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }> = [];

    let totalCyclomaticComplexity = 0;
    let totalCognitiveComplexity = 0;
    let totalLinesOfCode = 0;
    let totalHalsteadVolume = 0;
    let functionCount = 0;
    let classCount = 0;
    let methodCount = 0;

    for (const filePath of filePaths) {
      if (!fs.existsSync(filePath) || !filePath.match(/\.(ts|tsx|js|jsx)$/)) {
        continue;
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const sourceFile = ts.createSourceFile(
        filePath,
        content,
        ts.ScriptTarget.Latest,
        true
      );

      // è®¡ç®—è¡Œæ•°ï¼ˆæ’é™¤ç©ºè¡Œå’Œæ³¨é‡Šï¼‰
      const lines = content.split('\n').filter(line => 
        line.trim() !== '' && !line.trim().startsWith('//')
      );
      totalLinesOfCode += lines.length;

      // ç»Ÿè®¡ç±»å’Œæ–¹æ³•
      const classes = this.findNodesOfType(sourceFile, ts.isClassDeclaration);
      const methods = this.findNodesOfType(sourceFile, ts.isMethodDeclaration);
      const functions = this.findNodesOfType(sourceFile, ts.isFunctionDeclaration);
      
      classCount += classes.length;
      methodCount += methods.length;
      functionCount += functions.length;

      // åˆ†ææ¯ä¸ªå‡½æ•°/æ–¹æ³•çš„å¤æ‚åº¦
      const allFunctions = [...methods, ...functions];
      allFunctions.forEach(func => {
        totalCyclomaticComplexity += this.calculateCyclomaticComplexity(func);
        totalCognitiveComplexity += this.calculateCognitiveComplexity(func);
        totalHalsteadVolume += this.calculateHalsteadVolume(func);
      });

      // æ£€æŸ¥è¿è§„
      this.checkClassComplexity(sourceFile, filePath, violations);
      this.checkMethodComplexity(sourceFile, filePath, violations);
      this.checkCodeSmells(sourceFile, filePath, violations);
    }

    // è®¡ç®—å¹³å‡å€¼å’Œå¯ç»´æŠ¤æ€§æŒ‡æ•°
    const avgCyclomaticComplexity = functionCount > 0 ? totalCyclomaticComplexity / functionCount : 0;
    const avgCognitiveComplexity = functionCount > 0 ? totalCognitiveComplexity / functionCount : 0;
    const avgHalsteadVolume = functionCount > 0 ? totalHalsteadVolume / functionCount : 0;
    
    // ä½¿ç”¨ Microsoft å¯ç»´æŠ¤æ€§æŒ‡æ•°å…¬å¼
    const maintainabilityIndex = Math.max(0, 
      171 - 5.2 * Math.log(avgHalsteadVolume || 1) - 
      0.23 * avgCyclomaticComplexity - 
      16.2 * Math.log(totalLinesOfCode || 1)
    );

    // è®¡ç®—è´¨é‡è¯„åˆ† - åŸºäºè¿è§„æ•°é‡å’Œä¸¥é‡ç¨‹åº¦
    const errorCount = violations.filter(v => v.type === 'error').length;
    const warningCount = violations.filter(v => v.type === 'warning').length;
    const infoCount = violations.filter(v => v.type === 'info').length;

    // ä½¿ç”¨æŒ‡æ•°è¡°å‡å‡½æ•°è®¡ç®—è¯„åˆ†
    const score = Math.max(0, 100 * Math.exp(-0.1 * (errorCount * 3 + warningCount * 2 + infoCount * 1)));

    return {
      violations,
      metrics: {
        cyclomaticComplexity: avgCyclomaticComplexity,
        cognitiveComplexity: avgCognitiveComplexity,
        linesOfCode: totalLinesOfCode,
        maintainabilityIndex: Math.round(maintainabilityIndex),
        classCount,
        methodCount: methodCount + functionCount
      },
      score: Math.round(score)
    };
  }

  /**
   * æ£€æŸ¥ç±»å¤æ‚åº¦ - åŸºäº SOLID åŸåˆ™
   */
  private checkClassComplexity(
    sourceFile: ts.SourceFile,
    filePath: string,
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>
  ): void {
    const classes = this.findNodesOfType(sourceFile, ts.isClassDeclaration);
    
    classes.forEach(cls => {
      const className = cls.name?.text || 'Anonymous';
      const methods = this.findNodesOfType(cls, ts.isMethodDeclaration);
      const publicMethods = methods.filter(m => 
        !m.modifiers?.some(mod => mod.kind === ts.SyntaxKind.PrivateKeyword)
      );

      if (publicMethods.length > this.qualityThresholds.maxMethodsPerClass) {
        const { line, column } = this.getNodePosition(sourceFile, cls);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Class "${className}" has ${publicMethods.length} public methods (max: ${this.qualityThresholds.maxMethodsPerClass})`,
          rule: 'single-responsibility-principle',
          category: 'complexity',
          severity: 2
        });
      }
    });
  }

  /**
   * æ£€æŸ¥æ–¹æ³•å¤æ‚åº¦
   */
  private checkMethodComplexity(
    sourceFile: ts.SourceFile,
    filePath: string,
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>
  ): void {
    const methods = this.findNodesOfType(sourceFile, ts.isMethodDeclaration);
    const functions = this.findNodesOfType(sourceFile, ts.isFunctionDeclaration);
    const allFunctions = [...methods, ...functions];

    allFunctions.forEach(func => {
      const funcName = func.name?.getText() || 'anonymous';
      const cyclomaticComplexity = this.calculateCyclomaticComplexity(func);
      const cognitiveComplexity = this.calculateCognitiveComplexity(func);

      if (cyclomaticComplexity > this.qualityThresholds.cyclomaticComplexity) {
        const { line, column } = this.getNodePosition(sourceFile, func);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Function "${funcName}" has cyclomatic complexity of ${cyclomaticComplexity} (max: ${this.qualityThresholds.cyclomaticComplexity})`,
          rule: 'cyclomatic-complexity',
          category: 'complexity',
          severity: 2
        });
      }

      if (cognitiveComplexity > this.qualityThresholds.cognitiveComplexity) {
        const { line, column } = this.getNodePosition(sourceFile, func);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Function "${funcName}" has cognitive complexity of ${cognitiveComplexity} (max: ${this.qualityThresholds.cognitiveComplexity})`,
          rule: 'cognitive-complexity',
          category: 'complexity',
          severity: 2
        });
      }
    });
  }

  /**
   * æ£€æŸ¥ä»£ç å¼‚å‘³
   */
  private checkCodeSmells(
    sourceFile: ts.SourceFile,
    filePath: string,
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>
  ): void {
    // æ£€æŸ¥é•¿å‚æ•°åˆ—è¡¨
    const functions = this.findNodesOfType(sourceFile, ts.isFunctionDeclaration);
    const methods = this.findNodesOfType(sourceFile, ts.isMethodDeclaration);
    const allFunctions = [...functions, ...methods];

    allFunctions.forEach(func => {
      const paramCount = func.parameters.length;
      if (paramCount > this.qualityThresholds.maxParametersPerMethod) {
        const funcName = func.name?.getText() || 'anonymous';
        const { line, column } = this.getNodePosition(sourceFile, func);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Function "${funcName}" has ${paramCount} parameters (max: ${this.qualityThresholds.maxParametersPerMethod})`,
          rule: 'max-parameters',
          category: 'maintainability',
          severity: 2
        });
      }
    });

    // æ£€æŸ¥ç©ºçš„ catch å—
    const tryStatements = this.findNodesOfType(sourceFile, ts.isTryStatement);
    tryStatements.forEach(tryStmt => {
      if (tryStmt.catchClause && tryStmt.catchClause.block.statements.length === 0) {
        const { line, column } = this.getNodePosition(sourceFile, tryStmt.catchClause);
        violations.push({
          type: 'error',
          file: filePath,
          line,
          column,
          message: 'Empty catch block detected',
          rule: 'no-empty-catch',
          category: 'maintainability',
          severity: 3
        });
      }
    });
  }

  /**
   * è¾…åŠ©æ–¹æ³•ï¼šæŸ¥æ‰¾ç‰¹å®šç±»å‹çš„èŠ‚ç‚¹
   */
  private findNodesOfType<T extends ts.Node>(
    node: ts.Node,
    predicate: (node: ts.Node) => node is T
  ): T[] {
    const results: T[] = [];
    
    const visit = (child: ts.Node) => {
      if (predicate(child)) {
        results.push(child);
      }
      ts.forEachChild(child, visit);
    };
    
    visit(node);
    return results;
  }

  /**
   * è¾…åŠ©æ–¹æ³•ï¼šè·å–èŠ‚ç‚¹ä½ç½®
   */
  private getNodePosition(sourceFile: ts.SourceFile, node: ts.Node): { line: number; column: number } {
    const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
    return { line: line + 1, column: character + 1 };
  }
}

/**
 * ä»£ç å®¡æŸ¥èŒƒå›´
 * Code review scope
 */
export enum ReviewScope {
  COMPREHENSIVE = "comprehensive",
  DIAGNOSTIC = "diagnostic",
  SECURITY_ONLY = "security_only",
  QUALITY_ONLY = "quality_only"
}

/**
 * æ–‡ä»¶æ¸…ç†æ¨¡å¼
 * File cleanup mode
 */
export enum CleanupMode {
  SAFE = "safe",
  AGGRESSIVE = "aggressive",
  ANALYSIS_ONLY = "analysis_only"
}

/**
 * è´¨é‡æ£€æŸ¥ç»“æœ
 * Quality check result
 */
export interface QualityCheckResult {
  category: string;
  status: 'PASS' | 'FAIL' | 'WARNING';
  message: string;
  details?: string[];
  suggestions?: string[];
}

/**
 * æ–‡ä»¶æ¸…ç†ç»“æœ
 * File cleanup result
 */
export interface CleanupResult {
  filesAnalyzed: number;
  filesRemoved: number;
  directoriesOptimized: number;
  removedFiles: string[];
  warnings: string[];
  suggestions: string[];
}

/**
 * ç»¼åˆè´¨é‡æ£€æŸ¥å·¥å…·çš„è¾“å‡ºç»“æœ
 * Comprehensive quality check tool output result
 */
export interface CodeReviewAndCleanupResult {
  taskId: string;
  overallScore: number;
  qualityChecks: QualityCheckResult[];
  cleanupResults: CleanupResult;
  auditCheckpoints: AuditCheckpoint[];
  nextSteps: string[];
  workflowContinuation: {
    shouldProceed: boolean;
    nextTool?: string;
    nextToolParams?: Record<string, any>;
  };
}/**
 * ä»£ç å®¡æŸ¥å’Œæ¸…ç†å·¥å…·çš„å‚æ•°éªŒè¯schema
 * Code review and cleanup tool parameter validation schema
 */
export const codeReviewAndCleanupSchema = z.object({
  project: z
    .string()
    .min(1, {
      message: "Project parameter is required for multi-agent safety. Please specify the project name to ensure data isolation and prevent concurrent conflicts.",
    })
    .describe("REQUIRED - Target project context for code review and cleanup. MANDATORY for multi-agent concurrent safety. Ensures operations are performed in correct project context and prevents data conflicts between different agents. EXAMPLES: 'my-web-app', 'backend-api', 'mobile-client'. CRITICAL: This parameter prevents concurrent agent conflicts in both MCPHub gateway mode and single IDE mode."),
  taskId: z
    .string()
    .regex(UUID_V4_REGEX, {
      message: "Invalid task ID format. Must be a valid UUID v4 format (8-4-4-4-12 hexadecimal digits). EXAMPLE: 'a1b2c3d4-e5f6-4789-a012-b3c4d5e6f789'. Use list_tasks or query_task to find valid task IDs.",
    })
    .describe("Unique identifier of the task to review and cleanup. MUST BE: valid UUID v4 format from existing task in system. HOW TO GET: use list_tasks to see all tasks, or query_task to search by name/description. EXAMPLE: 'a1b2c3d4-e5f6-4789-a012-b3c4d5e6f789'. VALIDATION: 8-4-4-4-12 hexadecimal pattern."),
  reviewScope: z
    .nativeEnum(ReviewScope)
    .default(ReviewScope.COMPREHENSIVE)
    .describe("Scope of code review to perform. COMPREHENSIVE: Full quality, security, and cleanup analysis. DIAGNOSTIC: Focus on identifying specific issues. SECURITY_ONLY: Security vulnerabilities only. QUALITY_ONLY: Code quality standards only."),
  cleanupMode: z
    .nativeEnum(CleanupMode)
    .default(CleanupMode.SAFE)
    .describe("File cleanup mode. SAFE: Conservative cleanup of obvious temporary files. AGGRESSIVE: More thorough cleanup including build artifacts. ANALYSIS_ONLY: Analyze cleanup opportunities without making changes."),
  targetFiles: z
    .array(z.string())
    .optional()
    .describe("Optional array of specific files to review. If not provided, reviews all files related to the task."),
});

/**
 * æ‰§è¡Œä»£ç è´¨é‡æ£€æŸ¥
 * Execute code quality checks
 */
class CodeQualityChecker {
  /**
   * æ‰§è¡Œç»¼åˆä»£ç è´¨é‡æ£€æŸ¥
   * Execute comprehensive code quality checks
   */
  static async executeQualityChecks(
    task: Task,
    reviewScope: ReviewScope,
    targetFiles?: string[]
  ): Promise<QualityCheckResult[]> {
    const results: QualityCheckResult[] = [];

    if (reviewScope === ReviewScope.COMPREHENSIVE || reviewScope === ReviewScope.QUALITY_ONLY) {
      // ä»£ç æ ‡å‡†æ£€æŸ¥
      results.push(await this.checkCodeStandards(task, targetFiles));

      // å¤æ‚åº¦åˆ†æ
      results.push(await this.analyzeComplexity(task, targetFiles));

      // æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥
      results.push(await this.checkTestCoverage(task, targetFiles));
    }

    if (reviewScope === ReviewScope.COMPREHENSIVE || reviewScope === ReviewScope.SECURITY_ONLY) {
      // å®‰å…¨æ¼æ´æ£€æŸ¥
      results.push(await this.checkSecurityVulnerabilities(task, targetFiles));

      // è¾“å…¥éªŒè¯æ£€æŸ¥
      results.push(await this.checkInputValidation(task, targetFiles));
    }

    if (reviewScope === ReviewScope.COMPREHENSIVE || reviewScope === ReviewScope.DIAGNOSTIC) {
      // é”™è¯¯å¤„ç†æ£€æŸ¥
      results.push(await this.checkErrorHandling(task, targetFiles));

      // æ€§èƒ½é—®é¢˜æ£€æŸ¥
      results.push(await this.checkPerformanceIssues(task, targetFiles));
    }

    return results;
  }  /**
   * æ£€æŸ¥ä»£ç æ ‡å‡†
   * Check code standards
   */
  private static async checkCodeStandards(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      // ä½¿ç”¨çœŸå®çš„ä»£ç è´¨é‡æ£€æŸ¥å™¨ - æ¶ˆé™¤è™šå‡å®ç°
      // Use real code quality checker - eliminate fake implementations
      const qualityChecker = RealCodeQualityAnalyzer.getInstance();

      // è·å–è¦æ£€æŸ¥çš„æ–‡ä»¶è·¯å¾„ - ä¿®å¤ targetFiles å¤„ç†é€»è¾‘
      const filesToCheck: string[] = [];
      
      if (targetFiles && targetFiles.length > 0) {
        // å¦‚æœæŒ‡å®šäº† targetFilesï¼Œç›´æ¥ä½¿ç”¨è¿™äº›æ–‡ä»¶
        for (const filePath of targetFiles) {
          const fullPath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);
          if (fs.existsSync(fullPath)) {
            filesToCheck.push(fullPath);
          }
        }
      } else if (task.relatedFiles) {
        // å¦åˆ™ä½¿ç”¨ä»»åŠ¡çš„ç›¸å…³æ–‡ä»¶
        for (const file of task.relatedFiles) {
          const fullPath = path.isAbsolute(file.path) ? file.path : path.resolve(process.cwd(), file.path);
          if (fs.existsSync(fullPath)) {
            filesToCheck.push(fullPath);
          }
        }
      }

      // è°ƒè¯•ä¿¡æ¯
      console.log('DEBUG: targetFiles:', targetFiles);
      console.log('DEBUG: filesToCheck:', filesToCheck);
      console.log('DEBUG: task.relatedFiles:', task.relatedFiles?.map(f => f.path));

      if (filesToCheck.length === 0) {
        return {
          category: 'Code Standards',
          status: 'FAIL',
          message: `No files to check. targetFiles: ${JSON.stringify(targetFiles)}, task.relatedFiles: ${task.relatedFiles?.length || 0}`,
          details: ['Debug: Check file paths and existence'],
          suggestions: ['Verify file paths are correct and files exist']
        };
      }

      // ä½¿ç”¨å…¨æ–°çš„çœŸå®ä»£ç è´¨é‡åˆ†æå™¨
      console.log('ğŸ” [REAL ANALYZER] Starting comprehensive analysis...');
      const { RealCodeQualityAnalyzer } = await import('./realCodeQualityAnalyzer.js');
      const realAnalyzer = RealCodeQualityAnalyzer.getInstance();
      
      const analysisResult = await realAnalyzer.analyzeFiles(filesToCheck);
      
      const errorCount = analysisResult.violations.filter(v => v.type === 'error').length;
      const warningCount = analysisResult.violations.filter(v => v.type === 'warning').length;

      let status: 'PASS' | 'WARNING' | 'FAIL' = 'PASS';
      let message = 'Code standards check passed';
      const details: string[] = [];
      const suggestions: string[] = [];

      if (errorCount > 0) {
        status = 'FAIL';
        message = `âŒ REAL ANALYZER: Found ${errorCount} errors and ${warningCount} warnings (Health Score: ${analysisResult.healthScore}/100)`;
        details.push(...analysisResult.violations
          .filter(v => v.type === 'error')
          .slice(0, 10)
          .map(v => `${path.basename(v.file)}:${v.line}:${v.column} - ${v.message} (${v.rule})`));
        suggestions.push(...analysisResult.recommendations);
      } else if (warningCount > 5) {
        status = 'WARNING';
        message = `âš ï¸ REAL ANALYZER: Found ${warningCount} warnings (Health Score: ${analysisResult.healthScore}/100)`;
        details.push(...analysisResult.violations
          .filter(v => v.type === 'warning')
          .slice(0, 5)
          .map(v => `${path.basename(v.file)}:${v.line}:${v.column} - ${v.message} (${v.rule})`));
        suggestions.push(...analysisResult.recommendations);
      } else {
        message = `âœ… REAL ANALYZER: Code standards check passed (Health Score: ${analysisResult.healthScore}/100)`;
      }

      // æ·»åŠ åˆ†æç»Ÿè®¡ä¿¡æ¯
      details.push(`Files analyzed: ${analysisResult.summary.filesAnalyzed}`);
      details.push(`Total violations: ${analysisResult.summary.totalViolations}`);
      details.push(`Health score: ${analysisResult.healthScore}/100`);

      return {
        category: 'Code Standards',
        status,
        message,
        details,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Code Standards',
        status: 'FAIL',
        message: `Code standards check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review code standards checking implementation']
      };
    }
  }

  /**
   * åˆ†æä»£ç å¤æ‚åº¦
   * Analyze code complexity
   */
  private static async analyzeComplexity(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      // ä½¿ç”¨çœŸå®çš„å¤æ‚åº¦åˆ†æ - åŸºäº TypeScript AST
      // Use real complexity analysis - based on TypeScript AST
      const qualityChecker = RealCodeQualityAnalyzer.getInstance();

      // è·å–è¦åˆ†æçš„æ–‡ä»¶è·¯å¾„ - ä¿®å¤ targetFiles å¤„ç†é€»è¾‘
      const filesToAnalyze: string[] = [];
      
      if (targetFiles && targetFiles.length > 0) {
        // å¦‚æœæŒ‡å®šäº† targetFilesï¼Œç›´æ¥ä½¿ç”¨è¿™äº›æ–‡ä»¶
        for (const filePath of targetFiles) {
          const fullPath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);
          if (fs.existsSync(fullPath) && fullPath.match(/\.(ts|tsx|js|jsx)$/)) {
            filesToAnalyze.push(fullPath);
          }
        }
      } else if (task.relatedFiles) {
        // å¦åˆ™ä½¿ç”¨ä»»åŠ¡çš„ç›¸å…³æ–‡ä»¶
        for (const file of task.relatedFiles) {
          const fullPath = path.isAbsolute(file.path) ? file.path : path.resolve(process.cwd(), file.path);
          if (fs.existsSync(fullPath) && fullPath.match(/\.(ts|tsx|js|jsx)$/)) {
            filesToAnalyze.push(fullPath);
          }
        }
      }

      if (filesToAnalyze.length === 0) {
        return {
          category: 'Code Complexity',
          status: 'PASS',
          message: 'No TypeScript/JavaScript files to analyze',
          details: [],
          suggestions: []
        };
      }

      // æ‰§è¡ŒçœŸå®çš„å¤æ‚åº¦åˆ†æ
      const complexityAnalysis = await qualityChecker.analyzeCodeQuality(filesToAnalyze);

      let status: 'PASS' | 'WARNING' | 'FAIL' = 'PASS';
      let message = 'Code complexity within acceptable limits';
      const details: string[] = [];
      const suggestions: string[] = [];

      // æ£€æŸ¥å¤æ‚åº¦è¿è§„
      const complexityViolations = complexityAnalysis.violations.filter(v => v.category === 'complexity');
      if (complexityViolations.length > 0) {
        status = 'WARNING';
        details.push(...complexityViolations.slice(0, 5).map(v =>
          `${path.basename(v.file)}:${v.line}:${v.column} - ${v.message}`
        ));
        suggestions.push('Consider breaking down complex functions into smaller ones');
        suggestions.push('Reduce nested conditions and loops');
      }

      // æ£€æŸ¥å¯ç»´æŠ¤æ€§æŒ‡æ•°
      const maintainabilityThreshold = 50;
      if (complexityAnalysis.metrics.maintainabilityIndex < maintainabilityThreshold) {
        status = 'FAIL';
        details.push(`Maintainability index: ${complexityAnalysis.metrics.maintainabilityIndex} (threshold: ${maintainabilityThreshold})`);
        suggestions.push('Refactor code to improve maintainability');
      }

      // æ·»åŠ å¤æ‚åº¦æŒ‡æ ‡è¯¦æƒ…
      details.push(`Average cyclomatic complexity: ${complexityAnalysis.metrics.cyclomaticComplexity.toFixed(1)}`);
      details.push(`Average cognitive complexity: ${complexityAnalysis.metrics.cognitiveComplexity.toFixed(1)}`);
      details.push(`Lines of code: ${complexityAnalysis.metrics.linesOfCode}`);
      details.push(`Classes: ${complexityAnalysis.metrics.classCount}, Methods: ${complexityAnalysis.metrics.methodCount}`);

      if (status !== 'PASS') {
        message = `Code complexity issues detected`;
      }

      return {
        category: 'Code Complexity',
        status,
        message,
        details,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Code Complexity',
        status: 'FAIL',
        message: `Complexity analysis failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review complexity analysis implementation']
      };
    }
  }  /**
   * æ£€æŸ¥æµ‹è¯•è¦†ç›–ç‡
   * Check test coverage
   */
  private static async checkTestCoverage(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        const codeFiles = task.relatedFiles.filter(f =>
          f.type === 'TO_MODIFY' || f.type === 'CREATE'
        );
        const testFiles = task.relatedFiles.filter(f =>
          f.path.includes('test') || f.path.includes('spec')
        );

        if (codeFiles.length > 0 && testFiles.length === 0) {
          issues.push('No test files found for implementation');
          suggestions.push('Add unit tests for new functionality');
        }

        // æ£€æŸ¥æµ‹è¯•æ–‡ä»¶çš„è´¨é‡
        for (const testFile of testFiles) {
          if (fs.existsSync(testFile.path)) {
            const content = fs.readFileSync(testFile.path, 'utf-8');

            if (!content.includes('expect') && !content.includes('assert')) {
              issues.push(`Test file ${testFile.path} appears to have no assertions`);
              suggestions.push('Add proper test assertions to verify functionality');
            }
          }
        }
      }

      return {
        category: 'Test Coverage',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Test coverage check passed' : `Found ${issues.length} test coverage issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Test Coverage',
        status: 'FAIL',
        message: `Test coverage check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review test coverage checking implementation']
      };
    }
  }

  /**
   * æ£€æŸ¥å®‰å…¨æ¼æ´
   * Check security vulnerabilities
   */
  private static async checkSecurityVulnerabilities(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');
            // å®‰å…¨æ£€æŸ¥ä¿ç•™ï¼Œä½†ç§»é™¤å…¶ä»–ä¸è´¨é‡æ— å…³çš„å­—ç¬¦ä¸²è§„åˆ™
            if (content.includes('eval(') || content.includes('Function(')) {
              issues.push(`Dangerous eval() usage found in ${file.path}`);
              suggestions.push('Avoid using eval() or Function() constructor for security reasons');
            }
            // å…¶ä½™æ›´é«˜çº§å®‰å…¨æ£€æŸ¥åº”ç”±ä¸“ç”¨å®‰å…¨å·¥å…·å®Œæˆï¼Œè¿™é‡Œä¸ä½¿ç”¨ç®€å•å­—ç¬¦ä¸²è§„åˆ™ä»¥é¿å…è¯¯æŠ¥
          }
        }
      }

      return {
        category: 'Security',
        status: issues.length === 0 ? 'PASS' : 'FAIL',
        message: issues.length === 0 ? 'Security check passed' : `Found ${issues.length} security issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Security',
        status: 'FAIL',
        message: `Security check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review security checking implementation']
      };
    }
  }  /**
   * æ£€æŸ¥è¾“å…¥éªŒè¯
   * Check input validation
   */
  private static async checkInputValidation(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');

            // æ£€æŸ¥æ˜¯å¦æœ‰è¾“å…¥éªŒè¯
            if (content.includes('req.body') || content.includes('params') || content.includes('query')) {
              if (!content.includes('validate') && !content.includes('schema') && !content.includes('zod')) {
                issues.push(`Missing input validation in ${file.path}`);
                suggestions.push('Add input validation using Zod or similar validation library');
              }
            }
          }
        }
      }

      return {
        category: 'Input Validation',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Input validation check passed' : `Found ${issues.length} validation issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Input Validation',
        status: 'FAIL',
        message: `Input validation check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review input validation checking implementation']
      };
    }
  }

  /**
   * æ£€æŸ¥é”™è¯¯å¤„ç†
   * Check error handling
   */
  private static async checkErrorHandling(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');

            // æ£€æŸ¥å¼‚æ­¥æ“ä½œçš„é”™è¯¯å¤„ç†
            if (content.includes('await') || content.includes('Promise')) {
              if (!content.includes('try') && !content.includes('catch')) {
                issues.push(`Missing error handling for async operations in ${file.path}`);
                suggestions.push('Add try-catch blocks for async operations');
              }
            }
          }
        }
      }

      return {
        category: 'Error Handling',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Error handling check passed' : `Found ${issues.length} error handling issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Error Handling',
        status: 'FAIL',
        message: `Error handling check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review error handling checking implementation']
      };
    }
  }

  /**
   * æ£€æŸ¥æ€§èƒ½é—®é¢˜
   * Check performance issues
   */
  private static async checkPerformanceIssues(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');

            // æ£€æŸ¥æ½œåœ¨çš„æ€§èƒ½é—®é¢˜
            if (content.includes('for') && content.includes('for')) {
              const nestedLoops = (content.match(/for\s*\(/g) || []).length;
              if (nestedLoops > 2) {
                issues.push(`Potential performance issue: nested loops in ${file.path}`);
                suggestions.push('Consider optimizing nested loops or using more efficient algorithms');
              }
            }
          }
        }
      }

      return {
        category: 'Performance',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Performance check passed' : `Found ${issues.length} performance issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Performance',
        status: 'FAIL',
        message: `Performance check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review performance checking implementation']
      };
    }
  }
}/**
 * æ–‡ä»¶æ¸…ç†ç®¡ç†å™¨
 * File cleanup manager
 */
class FileCleanupManager {
  /**
   * æ‰§è¡Œæ–‡ä»¶æ¸…ç†
   * Execute file cleanup
   */
  static async executeCleanup(
    task: Task,
    cleanupMode: CleanupMode,
    projectPath: string
  ): Promise<CleanupResult> {
    const result: CleanupResult = {
      filesAnalyzed: 0,
      filesRemoved: 0,
      directoriesOptimized: 0,
      removedFiles: [],
      warnings: [],
      suggestions: []
    };

    try {
      // åˆ†æé¡¹ç›®ç›®å½•
      await this.analyzeProjectStructure(projectPath, result);

      if (cleanupMode !== CleanupMode.ANALYSIS_ONLY) {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        await this.cleanupTemporaryFiles(projectPath, cleanupMode, result);

        // æ¸…ç†æµ‹è¯•æ–‡ä»¶
        await this.cleanupTestFiles(projectPath, cleanupMode, result);

        // ä¼˜åŒ–ç›®å½•ç»“æ„
        await this.optimizeDirectoryStructure(projectPath, cleanupMode, result);
      }

      // ç”Ÿæˆå»ºè®®
      this.generateCleanupSuggestions(result);

    } catch (error) {
      result.warnings.push(`Cleanup operation failed: ${error instanceof Error ? error.message : String(error)}`);
    }

    return result;
  }

  /**
   * åˆ†æé¡¹ç›®ç»“æ„
   * Analyze project structure
   */
  private static async analyzeProjectStructure(projectPath: string, result: CleanupResult): Promise<void> {
    try {
      const analyzeDirectory = (dirPath: string) => {
        if (!fs.existsSync(dirPath)) return;

        const items = fs.readdirSync(dirPath);
        for (const item of items) {
          const itemPath = path.join(dirPath, item);
          const stat = fs.statSync(itemPath);

          if (stat.isFile()) {
            result.filesAnalyzed++;

            // è¯†åˆ«å¯èƒ½éœ€è¦æ¸…ç†çš„æ–‡ä»¶
            if (this.isTemporaryFile(item)) {
              result.suggestions.push(`Consider removing temporary file: ${itemPath}`);
            }
          } else if (stat.isDirectory() && !this.isSystemDirectory(item)) {
            analyzeDirectory(itemPath);
          }
        }
      };

      analyzeDirectory(projectPath);
    } catch (error) {
      result.warnings.push(`Failed to analyze project structure: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
   * Cleanup temporary files
   */
  private static async cleanupTemporaryFiles(
    projectPath: string,
    cleanupMode: CleanupMode,
    result: CleanupResult
  ): Promise<void> {
    const tempPatterns = [
      /\.tmp$/,
      /\.temp$/,
      /~$/,
      /\.bak$/,
      /\.swp$/,
      /\.log$/
    ];

    if (cleanupMode === CleanupMode.AGGRESSIVE) {
      tempPatterns.push(
        /node_modules/,
        /\.cache/,
        /dist/,
        /build/
      );
    }

    const cleanupDirectory = async (dirPath: string) => {
      if (!fs.existsSync(dirPath)) return;

      const items = fs.readdirSync(dirPath);
      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const stat = fs.statSync(itemPath);

        if (stat.isFile()) {
          const shouldRemove = tempPatterns.some(pattern => pattern.test(item));
          if (shouldRemove) {
            try {
              await withFileLock(itemPath, async () => {
                fs.unlinkSync(itemPath);
                result.filesRemoved++;
                result.removedFiles.push(itemPath);
              });
            } catch (error) {
              result.warnings.push(`Failed to remove ${itemPath}: ${error instanceof Error ? error.message : String(error)}`);
            }
          }
        } else if (stat.isDirectory() && !this.isSystemDirectory(item)) {
          await cleanupDirectory(itemPath);
        }
      }
    };

    await cleanupDirectory(projectPath);
  }  /**
   * æ¸…ç†æµ‹è¯•æ–‡ä»¶
   * Cleanup test files
   */
  private static async cleanupTestFiles(
    projectPath: string,
    cleanupMode: CleanupMode,
    result: CleanupResult
  ): Promise<void> {
    // åªåœ¨å®‰å…¨æ¨¡å¼ä¸‹æ¸…ç†æ˜æ˜¾çš„æµ‹è¯•ä¸´æ—¶æ–‡ä»¶
    if (cleanupMode === CleanupMode.SAFE) {
      const testTempPatterns = [
        /test.*\.tmp$/,
        /spec.*\.tmp$/,
        /\.test\.log$/,
        /coverage.*\.tmp$/
      ];

      const cleanupTestDirectory = async (dirPath: string) => {
        if (!fs.existsSync(dirPath)) return;

        const items = fs.readdirSync(dirPath);
        for (const item of items) {
          const itemPath = path.join(dirPath, item);
          const stat = fs.statSync(itemPath);

          if (stat.isFile()) {
            const shouldRemove = testTempPatterns.some(pattern => pattern.test(item));
            if (shouldRemove) {
              try {
                fs.unlinkSync(itemPath);
                result.filesRemoved++;
                result.removedFiles.push(itemPath);
              } catch (error) {
                result.warnings.push(`Failed to remove test file ${itemPath}: ${error instanceof Error ? error.message : String(error)}`);
              }
            }
          } else if (stat.isDirectory() && (item.includes('test') || item.includes('spec'))) {
            await cleanupTestDirectory(itemPath);
          }
        }
      };

      await cleanupTestDirectory(projectPath);
    }
  }

  /**
   * ä¼˜åŒ–ç›®å½•ç»“æ„
   * Optimize directory structure
   */
  private static async optimizeDirectoryStructure(
    projectPath: string,
    cleanupMode: CleanupMode,
    result: CleanupResult
  ): Promise<void> {
    try {
      // æ£€æŸ¥ç©ºç›®å½•
      const checkEmptyDirectories = (dirPath: string) => {
        if (!fs.existsSync(dirPath)) return;

        const items = fs.readdirSync(dirPath);
        for (const item of items) {
          const itemPath = path.join(dirPath, item);
          const stat = fs.statSync(itemPath);

          if (stat.isDirectory() && !this.isSystemDirectory(item)) {
            checkEmptyDirectories(itemPath);

            // æ£€æŸ¥ç›®å½•æ˜¯å¦ä¸ºç©º
            const dirItems = fs.readdirSync(itemPath);
            if (dirItems.length === 0) {
              try {
                fs.rmdirSync(itemPath);
                result.directoriesOptimized++;
                result.suggestions.push(`Removed empty directory: ${itemPath}`);
              } catch (error) {
                result.warnings.push(`Failed to remove empty directory ${itemPath}: ${error instanceof Error ? error.message : String(error)}`);
              }
            }
          }
        }
      };

      checkEmptyDirectories(projectPath);
    } catch (error) {
      result.warnings.push(`Directory optimization failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * ç”Ÿæˆæ¸…ç†å»ºè®®
   * Generate cleanup suggestions
   */
  private static generateCleanupSuggestions(result: CleanupResult): void {
    if (result.filesRemoved === 0) {
      result.suggestions.push('Project appears to be clean - no temporary files found');
    } else {
      result.suggestions.push(`Successfully cleaned ${result.filesRemoved} temporary files`);
    }

    if (result.directoriesOptimized > 0) {
      result.suggestions.push(`Optimized ${result.directoriesOptimized} directories`);
    }

    result.suggestions.push('Consider running cleanup regularly to maintain project hygiene');
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºä¸´æ—¶æ–‡ä»¶
   * Check if file is temporary
   */
  private static isTemporaryFile(filename: string): boolean {
    const tempPatterns = [
      /\.tmp$/,
      /\.temp$/,
      /~$/,
      /\.bak$/,
      /\.swp$/,
      /\.log$/,
      /\.cache$/
    ];

    return tempPatterns.some(pattern => pattern.test(filename));
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿç›®å½•
   * Check if directory is system directory
   */
  private static isSystemDirectory(dirname: string): boolean {
    const systemDirs = [
      '.git',
      '.vscode',
      '.idea',
      'node_modules',
      '.next',
      '.nuxt',
      'dist',
      'build'
    ];

    return systemDirs.includes(dirname);
  }
}/**
 * ä»£ç å®¡æŸ¥å’Œæ¸…ç†å·¥å…·ä¸»å‡½æ•°
 * Code review and cleanup tool main function
 */
export async function codeReviewAndCleanupTool({
  project,
  taskId,
  reviewScope,
  cleanupMode,
  targetFiles,
}: z.infer<typeof codeReviewAndCleanupSchema>) {
  const { ProjectSession } = await import("../../utils/projectSession.js");

  return await ProjectSession.withProjectContext(project, async () => {
    try {
      // è·å–ä»»åŠ¡ä¿¡æ¯
      const task = await getTaskById(taskId, project);
      if (!task) {
        return createNotFoundError(
          "Task",
          taskId,
          "Use list_tasks to see all available tasks, or query_task to search by name/description"
        );
      }

      // æ‰§è¡Œä»£ç è´¨é‡æ£€æŸ¥
      const qualityChecks = await CodeQualityChecker.executeQualityChecks(
        task,
        reviewScope,
        targetFiles
      );

      // è·å–é¡¹ç›®è·¯å¾„
      const projectPath = process.cwd(); // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä»é¡¹ç›®é…ç½®è·å–

      // æ‰§è¡Œæ–‡ä»¶æ¸…ç†
      const cleanupResults = await FileCleanupManager.executeCleanup(
        task,
        cleanupMode,
        projectPath
      );

      // ç”Ÿæˆå®¡è®¡æ£€æŸ¥ç‚¹
      const auditCheckpoints = generateAuditCheckpoints(task, qualityChecks);

      // è®¡ç®—æ€»ä½“è¯„åˆ†
      const overallScore = calculateOverallScore(qualityChecks);

      // ç”Ÿæˆä¸‹ä¸€æ­¥å»ºè®®
      const nextSteps = generateNextSteps(qualityChecks, cleanupResults, overallScore);

      // æŸ¥æ‰¾æˆ–åˆ›å»ºå·¥ä½œæµä¸Šä¸‹æ–‡
      let workflow = SimpleWorkflowManager.findWorkflowByTaskId(taskId);
      if (!workflow) {
        // åˆ›å»ºæ ‡å‡†çš„ä»»åŠ¡éªŒè¯å·¥ä½œæµ
        workflow = SimpleWorkflowManager.createWorkflow(
          taskId,
          project,
          ["verify_task", "code_review_and_cleanup_tool", "execute_task"]
        );
      }

      // æ›´æ–°å½“å‰æ­¥éª¤çŠ¶æ€
      const currentStepIndex = workflow.steps.findIndex(s => s.tool === "code_review_and_cleanup_tool");
      if (currentStepIndex >= 0) {
        SimpleWorkflowManager.updateStepStatus(
          workflow.workflowId,
          currentStepIndex,
          overallScore >= 80 ? WorkflowStatus.COMPLETED : WorkflowStatus.FAILED,
          { overallScore, qualityChecks, cleanupResults },
          overallScore < 80 ? "Quality standards not met" : undefined
        );
      }

      // ç”Ÿæˆå·¥ä½œæµç»§ç»­æŒ‡å¯¼
      const workflowContinuation = SimpleWorkflowManager.generateContinuation(workflow.workflowId);

      const result: CodeReviewAndCleanupResult = {
        taskId,
        overallScore,
        qualityChecks,
        cleanupResults,
        auditCheckpoints,
        nextSteps,
        workflowContinuation
      };

      // ç”Ÿæˆç»“æ„åŒ–çš„å“åº”æç¤ºè¯
      const responsePrompt = generateResponsePrompt(result);

      // ä½¿ç”¨å·¥ä½œæµæ„ŸçŸ¥çš„å“åº”æ ¼å¼
      return createWorkflowResponse(responsePrompt, workflowContinuation);

    } catch (error) {
      return createInternalError(
        "Code review and cleanup",
        error instanceof Error ? error : new Error(String(error))
      );
    }
  });
}

/**
 * ç”Ÿæˆå®¡è®¡æ£€æŸ¥ç‚¹
 * Generate audit checkpoints
 */
function generateAuditCheckpoints(task: Task, qualityChecks: QualityCheckResult[]): AuditCheckpoint[] {
  const checkpoints: AuditCheckpoint[] = [];

  // åŸºäºè´¨é‡æ£€æŸ¥ç»“æœç”Ÿæˆæ£€æŸ¥ç‚¹
  qualityChecks.forEach(check => {
    if (check.status === 'FAIL') {
      checkpoints.push({
        name: `${check.category} Review`,
        description: check.message,
        mandatory: true,
        timing: 'BEFORE_COMPLETION',
        criteria: check.details || [],
        tools: ['code-review', 'static-analysis']
      });
    }
  });

  // æ·»åŠ é€šç”¨å®‰å…¨æ£€æŸ¥ç‚¹
  checkpoints.push({
    name: 'Security Review',
    description: 'Comprehensive security vulnerability assessment',
    mandatory: true,
    timing: 'BEFORE_COMPLETION',
    criteria: ['No security vulnerabilities', 'Input validation present', 'Access controls proper'],
    tools: ['security-scan', 'vulnerability-check', 'access-review']
  });

  return checkpoints;
}

/**
 * è®¡ç®—æ€»ä½“è¯„åˆ†
 * Calculate overall score
 */
function calculateOverallScore(qualityChecks: QualityCheckResult[]): number {
  if (qualityChecks.length === 0) return 100;

  // åŸºäºç±»åˆ«çš„åŠ æƒè¯„åˆ†ï¼Œé¿å…â€œPASS=100/FAIL=30â€ç®€åŒ–
  const weights: Record<string, number> = {
    'Code Standards': 0.25,      // ESLint é”™è¯¯å’Œè­¦å‘Š
    'Code Complexity': 0.30,     // å¾ªç¯å¤æ‚åº¦å’Œè®¤çŸ¥å¤æ‚åº¦
    'Test Coverage': 0.20,       // å®é™…æµ‹è¯•è¦†ç›–ç‡
    'Security': 0.15,            // å®‰å…¨æ¼æ´æ£€æµ‹
    'Maintainability': 0.10,     // å¯ç»´æŠ¤æ€§æŒ‡æ•°
  };

  let score = 0;
  let totalWeight = 0;

  for (const check of qualityChecks) {
    const w = weights[check.category] ?? 0.05;
    totalWeight += w;
    // åŸºäºçœŸå®æ•°å€¼è®¡ç®—è¯„åˆ†ï¼Œæ¶ˆé™¤è™šå‡çš„ PASS=100/WARNING=70/FAIL=30 è¯„åˆ†
    let categoryScore = 100;

    if (check.details && check.details.length > 0) {
      // æ ¹æ®é—®é¢˜æ•°é‡å’Œä¸¥é‡ç¨‹åº¦è®¡ç®—çœŸå®è¯„åˆ†
      const issueCount = check.details.length;
      const severity = check.status === 'FAIL' ? 3 : check.status === 'WARNING' ? 2 : 1;

      // ä½¿ç”¨æŒ‡æ•°è¡°å‡å‡½æ•°è®¡ç®—è¯„åˆ†ï¼Œé¿å…çº¿æ€§æƒ©ç½š
      categoryScore = Math.max(0, 100 * Math.exp(-0.1 * issueCount * severity));
    }

    score += categoryScore * w;
  }

  if (totalWeight === 0) return 100;
  return Math.round(score / totalWeight);
}/**
 * ç”Ÿæˆä¸‹ä¸€æ­¥å»ºè®®
 * Generate next steps
 */
function generateNextSteps(
  qualityChecks: QualityCheckResult[],
  cleanupResults: CleanupResult,
  overallScore: number
): string[] {
  const steps: string[] = [];

  // åŸºäºè´¨é‡æ£€æŸ¥ç»“æœç”Ÿæˆå»ºè®®
  qualityChecks.forEach(check => {
    if (check.status === 'FAIL' && check.suggestions) {
      steps.push(...check.suggestions);
    }
  });

  // åŸºäºæ¸…ç†ç»“æœç”Ÿæˆå»ºè®®
  if (cleanupResults.suggestions) {
    steps.push(...cleanupResults.suggestions);
  }

  // åŸºäºæ€»ä½“è¯„åˆ†ç”Ÿæˆå»ºè®®
  if (overallScore >= 80) {
    steps.push('Quality standards met - ready to proceed to next task');
  } else {
    steps.push('Address quality issues before proceeding');
    steps.push('Re-run code review after fixes');
  }

  return steps;
}

/**
 * ç¡®å®šå·¥ä½œæµç¨‹ç»§ç»­
 * Determine workflow continuation
 */
function determineWorkflowContinuation(overallScore: number, project: string): {
  shouldProceed: boolean;
  nextTool?: string;
  nextToolParams?: Record<string, any>;
} {
  if (overallScore >= 80) {
    return {
      shouldProceed: true,
      nextTool: 'execute_task',
      nextToolParams: {
        project: project,
        // ä¸‹ä¸€ä¸ªä»»åŠ¡IDéœ€è¦ä»ä»»åŠ¡åˆ—è¡¨ä¸­è·å–
      }
    };
  } else {
    return {
      shouldProceed: false
    };
  }
}

/**
 * ç”Ÿæˆå“åº”æç¤ºè¯
 * Generate response prompt
 */
function generateResponsePrompt(result: CodeReviewAndCleanupResult): string {
  let prompt = `## ğŸ” Code Review and Cleanup Results\n\n`;

  prompt += `**Task ID:** ${result.taskId}\n`;
  prompt += `**Overall Quality Score:** ${result.overallScore}/100\n\n`;

  // è´¨é‡æ£€æŸ¥ç»“æœ
  prompt += `### Quality Check Results\n\n`;
  result.qualityChecks.forEach(check => {
    const statusIcon = check.status === 'PASS' ? 'âœ…' : check.status === 'WARNING' ? 'âš ï¸' : 'âŒ';
    prompt += `${statusIcon} **${check.category}**: ${check.message}\n`;

    if (check.details && check.details.length > 0) {
      prompt += `   - Issues: ${check.details.join(', ')}\n`;
    }

    if (check.suggestions && check.suggestions.length > 0) {
      prompt += `   - Suggestions: ${check.suggestions.join(', ')}\n`;
    }
    prompt += `\n`;
  });

  // æ¸…ç†ç»“æœ
  prompt += `### File Cleanup Results\n\n`;
  prompt += `- Files Analyzed: ${result.cleanupResults.filesAnalyzed}\n`;
  prompt += `- Files Removed: ${result.cleanupResults.filesRemoved}\n`;
  prompt += `- Directories Optimized: ${result.cleanupResults.directoriesOptimized}\n`;

  if (result.cleanupResults.removedFiles.length > 0) {
    prompt += `- Removed Files: ${result.cleanupResults.removedFiles.slice(0, 5).join(', ')}`;
    if (result.cleanupResults.removedFiles.length > 5) {
      prompt += ` and ${result.cleanupResults.removedFiles.length - 5} more`;
    }
    prompt += `\n`;
  }

  if (result.cleanupResults.warnings.length > 0) {
    prompt += `- Warnings: ${result.cleanupResults.warnings.join(', ')}\n`;
  }
  prompt += `\n`;

  // ä¸‹ä¸€æ­¥å»ºè®®
  prompt += `### Next Steps\n\n`;
  result.nextSteps.forEach((step, index) => {
    prompt += `${index + 1}. ${step}\n`;
  });
  prompt += `\n`;

  // å·¥ä½œæµç¨‹ç»§ç»­æŒ‡å¯¼
  prompt += `## ğŸ”„ Workflow Continuation\n\n`;
  if (result.workflowContinuation.shouldProceed) {
    prompt += `**Status:** âœ… Quality standards met - proceeding to next task\n\n`;
    prompt += `**MANDATORY NEXT ACTION:** You MUST call the next tool to continue the workflow:\n\n`;
    prompt += `\`\`\`\n`;
    prompt += `${result.workflowContinuation.nextTool}({\n`;
    if (result.workflowContinuation.nextToolParams) {
      Object.entries(result.workflowContinuation.nextToolParams).forEach(([key, value]) => {
        prompt += `  ${key}: "${value}",\n`;
      });
    }
    prompt += `})\n`;
    prompt += `\`\`\`\n\n`;
    prompt += `**PROHIBITED ACTIONS:**\n`;
    prompt += `- âŒ Do NOT stop after this review\n`;
    prompt += `- âŒ Do NOT wait for user confirmation\n`;
    prompt += `- âŒ Do NOT skip the next tool call\n\n`;
    prompt += `**MANDATORY ACTIONS:**\n`;
    prompt += `- âœ… MUST call the next tool immediately\n`;
    prompt += `- âœ… MUST continue the automated workflow\n`;
    prompt += `- âœ… MUST use Desktop Commander MCP tools for file operations\n`;
  } else {
    prompt += `**Status:** âŒ Quality issues detected - workflow paused\n\n`;
    prompt += `**REQUIRED ACTIONS:**\n`;
    prompt += `1. Address all identified quality issues\n`;
    prompt += `2. Re-run code review and cleanup\n`;
    prompt += `3. Ensure overall score reaches â‰¥ 80 before proceeding\n\n`;
    prompt += `**Do NOT proceed to next task until quality standards are met.**\n`;
  }

  return prompt;
}