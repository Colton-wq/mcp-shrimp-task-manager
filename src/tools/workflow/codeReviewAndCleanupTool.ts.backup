import { z } from "zod";
import { UUID_V4_REGEX } from "../../utils/regex.js";
import { getTaskById, getAllTasks } from "../../models/taskModel.js";
import { TaskStatus, Task } from "../../types/index.js";
import { withFileLock } from "../../utils/fileLock.js";
import {
  createSuccessResponse,
  createNotFoundError,
  createValidationError,
  createInternalError,
  createWorkflowResponse,
} from "../../utils/mcpResponse.js";
import { SimpleWorkflowManager } from "../../utils/workflowManager.js";
import { WorkflowStatus } from "../../types/workflow.js";
import { AuditCheckpoint, TaskType } from "../../prompts/generators/executeTask.js";
import * as fs from "fs";
import * as path from "path";
import * as ts from "typescript";

// 导入真实的代码质量检查器 - 消除虚假实现
// Import real code quality checker - eliminate fake implementations
// 注意：由于路径复杂性，我们将直接在此文件中实现真实的质量检查逻辑
/**
 * 真实的代码质量分析器 - 消除虚假实现
 * Real Code Quality Analyzer - Eliminate Fake Implementations
 */
class RealCodeQualityAnalyzer {
  private static instance: RealCodeQualityAnalyzer;

  private readonly qualityThresholds = {
    cyclomaticComplexity: 10,
    cognitiveComplexity: 15,
    linesOfCode: 300,
    maintainabilityIndex: 50,
    eslintErrorsPerFile: 0,
    eslintWarningsPerFile: 5,
  };

  public static getInstance(): RealCodeQualityAnalyzer {
    if (!RealCodeQualityAnalyzer.instance) {
      RealCodeQualityAnalyzer.instance = new RealCodeQualityAnalyzer();
    }
    return RealCodeQualityAnalyzer.instance;
  }

  /**
   * 运行真实的 ESLint 分析
   */
  public async runESLintAnalysis(filePaths: string[]): Promise<Array<{
    type: 'error' | 'warning';
    file: string;
    line: number;
    column: number;
    message: string;
    rule: string;
  }>> {
    const issues: Array<{
      type: 'error' | 'warning';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
    }> = [];

    try {
      // 动态导入 ESLint 以避免构建时依赖问题
      const { ESLint } = await import('eslint');

      const eslint = new ESLint({
        overrideConfigFile: undefined, // 使用项目的 ESLint 配置
        fix: false,
        cwd: process.cwd()
      });

      const results = await eslint.lintFiles(filePaths);

      for (const result of results) {
        for (const message of result.messages) {
          issues.push({
            type: message.severity === 2 ? 'error' : 'warning',
            file: result.filePath,
            line: message.line,
            column: message.column,
            message: message.message,
            rule: message.ruleId || 'unknown'
          });
        }
      }
    } catch (error) {
      // 如果 ESLint 不可用，返回空数组而不是抛出错误
      console.warn('ESLint not available, skipping lint analysis:', error);
    }

    return issues;
  }

  /**
   * 计算真实的代码复杂度指标
   */
  public async calculateComplexity(filePaths: string[]): Promise<{
    cyclomaticComplexity: number;
    cognitiveComplexity: number;
    linesOfCode: number;
    maintainabilityIndex: number;
  }> {
    let totalCyclomaticComplexity = 0;
    let totalCognitiveComplexity = 0;
    let totalLinesOfCode = 0;
    let functionCount = 0;

    for (const filePath of filePaths) {
      if (!fs.existsSync(filePath) || !filePath.match(/\.(ts|tsx|js|jsx)$/)) {
        continue;
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const sourceFile = ts.createSourceFile(
        filePath,
        content,
        ts.ScriptTarget.Latest,
        true
      );

      // 计算行数（排除空行和注释）
      const lines = content.split('\n').filter(line =>
        line.trim() !== '' && !line.trim().startsWith('//')
      );
      totalLinesOfCode += lines.length;

      // 遍历 AST 计算复杂度
      const visitor = (node: ts.Node) => {
        if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) || ts.isArrowFunction(node)) {
          functionCount++;
          totalCyclomaticComplexity += this.calculateCyclomaticComplexity(node);
          totalCognitiveComplexity += this.calculateCognitiveComplexity(node);
        }
        ts.forEachChild(node, visitor);
      };

      visitor(sourceFile);
    }

    // 计算可维护性指数 - 使用 Microsoft 公式
    const avgCyclomaticComplexity = functionCount > 0 ? totalCyclomaticComplexity / functionCount : 0;
    const maintainabilityIndex = Math.max(0,
      171 - 5.2 * Math.log(totalLinesOfCode || 1) -
      0.23 * avgCyclomaticComplexity -
      16.2 * Math.log(totalLinesOfCode || 1)
    );

    return {
      cyclomaticComplexity: avgCyclomaticComplexity,
      cognitiveComplexity: totalCognitiveComplexity / Math.max(functionCount, 1),
      linesOfCode: totalLinesOfCode,
      maintainabilityIndex: Math.round(maintainabilityIndex)
    };
  }

  /**
   * 计算循环复杂度 - 基于决策点
   */
  private calculateCyclomaticComplexity(node: ts.Node): number {
    let complexity = 1; // 基础复杂度

    const visitor = (child: ts.Node) => {
      // 决策点：if, while, for, switch case, catch, &&, ||, ?:
      if (ts.isIfStatement(child) ||
          ts.isWhileStatement(child) ||
          ts.isForStatement(child) ||
          ts.isForInStatement(child) ||
          ts.isForOfStatement(child) ||
          ts.isCaseClause(child) ||
          ts.isCatchClause(child) ||
          ts.isConditionalExpression(child)) {
        complexity++;
      }

      // 逻辑运算符
      if (ts.isBinaryExpression(child)) {
        if (child.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
            child.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
          complexity++;
        }
      }

      ts.forEachChild(child, visitor);
    };

    ts.forEachChild(node, visitor);
    return complexity;
  }

  /**
   * 计算认知复杂度 - 基于嵌套深度
   */
  private calculateCognitiveComplexity(node: ts.Node): number {
    let complexity = 0;

    const visitor = (child: ts.Node, level: number) => {
      if (ts.isIfStatement(child) ||
          ts.isWhileStatement(child) ||
          ts.isForStatement(child) ||
          ts.isSwitchStatement(child)) {
        complexity += 1 + level;
        level++;
      }

      ts.forEachChild(child, (grandChild) => visitor(grandChild, level));
    };

    ts.forEachChild(node, (child) => visitor(child, 0));
    return complexity;
  }

  /**
   * 基于成功 MCP 模式的综合代码分析 - 参考 code-auditor-mcp
   * Comprehensive code analysis based on successful MCP patterns
   */
  public async analyzeCodeQuality(filePaths: string[]): Promise<{
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>;
    metrics: {
      cyclomaticComplexity: number;
      cognitiveComplexity: number;
      linesOfCode: number;
      maintainabilityIndex: number;
      classCount: number;
      methodCount: number;
    };
    score: number;
  }> {
    const violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }> = [];

    let totalCyclomaticComplexity = 0;
    let totalCognitiveComplexity = 0;
    let totalLinesOfCode = 0;
    let totalHalsteadVolume = 0;
    let functionCount = 0;
    let classCount = 0;
    let methodCount = 0;

    for (const filePath of filePaths) {
      if (!fs.existsSync(filePath) || !filePath.match(/\.(ts|tsx|js|jsx)$/)) {
        continue;
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const sourceFile = ts.createSourceFile(
        filePath,
        content,
        ts.ScriptTarget.Latest,
        true
      );

      // 计算行数（排除空行和注释）
      const lines = content.split('\n').filter(line => 
        line.trim() !== '' && !line.trim().startsWith('//')
      );
      totalLinesOfCode += lines.length;

      // 统计类和方法
      const classes = this.findNodesOfType(sourceFile, ts.isClassDeclaration);
      const methods = this.findNodesOfType(sourceFile, ts.isMethodDeclaration);
      const functions = this.findNodesOfType(sourceFile, ts.isFunctionDeclaration);
      
      classCount += classes.length;
      methodCount += methods.length;
      functionCount += functions.length;

      // 分析每个函数/方法的复杂度
      const allFunctions = [...methods, ...functions];
      allFunctions.forEach(func => {
        totalCyclomaticComplexity += this.calculateCyclomaticComplexity(func);
        totalCognitiveComplexity += this.calculateCognitiveComplexity(func);
        totalHalsteadVolume += this.calculateHalsteadVolume(func);
      });

      // 检查违规
      this.checkClassComplexity(sourceFile, filePath, violations);
      this.checkMethodComplexity(sourceFile, filePath, violations);
      this.checkCodeSmells(sourceFile, filePath, violations);
    }

    // 计算平均值和可维护性指数
    const avgCyclomaticComplexity = functionCount > 0 ? totalCyclomaticComplexity / functionCount : 0;
    const avgCognitiveComplexity = functionCount > 0 ? totalCognitiveComplexity / functionCount : 0;
    const avgHalsteadVolume = functionCount > 0 ? totalHalsteadVolume / functionCount : 0;
    
    // 使用 Microsoft 可维护性指数公式
    const maintainabilityIndex = Math.max(0, 
      171 - 5.2 * Math.log(avgHalsteadVolume || 1) - 
      0.23 * avgCyclomaticComplexity - 
      16.2 * Math.log(totalLinesOfCode || 1)
    );

    // 计算质量评分 - 基于违规数量和严重程度
    const errorCount = violations.filter(v => v.type === 'error').length;
    const warningCount = violations.filter(v => v.type === 'warning').length;
    const infoCount = violations.filter(v => v.type === 'info').length;

    // 使用指数衰减函数计算评分
    const score = Math.max(0, 100 * Math.exp(-0.1 * (errorCount * 3 + warningCount * 2 + infoCount * 1)));

    return {
      violations,
      metrics: {
        cyclomaticComplexity: avgCyclomaticComplexity,
        cognitiveComplexity: avgCognitiveComplexity,
        linesOfCode: totalLinesOfCode,
        maintainabilityIndex: Math.round(maintainabilityIndex),
        classCount,
        methodCount: methodCount + functionCount
      },
      score: Math.round(score)
    };
  }

  /**
   * 检查类复杂度 - 基于 SOLID 原则
   */
  private checkClassComplexity(
    sourceFile: ts.SourceFile,
    filePath: string,
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>
  ): void {
    const classes = this.findNodesOfType(sourceFile, ts.isClassDeclaration);
    
    classes.forEach(cls => {
      const className = cls.name?.text || 'Anonymous';
      const methods = this.findNodesOfType(cls, ts.isMethodDeclaration);
      const publicMethods = methods.filter(m => 
        !m.modifiers?.some(mod => mod.kind === ts.SyntaxKind.PrivateKeyword)
      );

      if (publicMethods.length > this.qualityThresholds.maxMethodsPerClass) {
        const { line, column } = this.getNodePosition(sourceFile, cls);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Class "${className}" has ${publicMethods.length} public methods (max: ${this.qualityThresholds.maxMethodsPerClass})`,
          rule: 'single-responsibility-principle',
          category: 'complexity',
          severity: 2
        });
      }
    });
  }

  /**
   * 检查方法复杂度
   */
  private checkMethodComplexity(
    sourceFile: ts.SourceFile,
    filePath: string,
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>
  ): void {
    const methods = this.findNodesOfType(sourceFile, ts.isMethodDeclaration);
    const functions = this.findNodesOfType(sourceFile, ts.isFunctionDeclaration);
    const allFunctions = [...methods, ...functions];

    allFunctions.forEach(func => {
      const funcName = func.name?.getText() || 'anonymous';
      const cyclomaticComplexity = this.calculateCyclomaticComplexity(func);
      const cognitiveComplexity = this.calculateCognitiveComplexity(func);

      if (cyclomaticComplexity > this.qualityThresholds.cyclomaticComplexity) {
        const { line, column } = this.getNodePosition(sourceFile, func);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Function "${funcName}" has cyclomatic complexity of ${cyclomaticComplexity} (max: ${this.qualityThresholds.cyclomaticComplexity})`,
          rule: 'cyclomatic-complexity',
          category: 'complexity',
          severity: 2
        });
      }

      if (cognitiveComplexity > this.qualityThresholds.cognitiveComplexity) {
        const { line, column } = this.getNodePosition(sourceFile, func);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Function "${funcName}" has cognitive complexity of ${cognitiveComplexity} (max: ${this.qualityThresholds.cognitiveComplexity})`,
          rule: 'cognitive-complexity',
          category: 'complexity',
          severity: 2
        });
      }
    });
  }

  /**
   * 检查代码异味
   */
  private checkCodeSmells(
    sourceFile: ts.SourceFile,
    filePath: string,
    violations: Array<{
      type: 'error' | 'warning' | 'info';
      file: string;
      line: number;
      column: number;
      message: string;
      rule: string;
      category: 'complexity' | 'maintainability' | 'standards' | 'security';
      severity: number;
    }>
  ): void {
    // 检查长参数列表
    const functions = this.findNodesOfType(sourceFile, ts.isFunctionDeclaration);
    const methods = this.findNodesOfType(sourceFile, ts.isMethodDeclaration);
    const allFunctions = [...functions, ...methods];

    allFunctions.forEach(func => {
      const paramCount = func.parameters.length;
      if (paramCount > this.qualityThresholds.maxParametersPerMethod) {
        const funcName = func.name?.getText() || 'anonymous';
        const { line, column } = this.getNodePosition(sourceFile, func);
        violations.push({
          type: 'warning',
          file: filePath,
          line,
          column,
          message: `Function "${funcName}" has ${paramCount} parameters (max: ${this.qualityThresholds.maxParametersPerMethod})`,
          rule: 'max-parameters',
          category: 'maintainability',
          severity: 2
        });
      }
    });

    // 检查空的 catch 块
    const tryStatements = this.findNodesOfType(sourceFile, ts.isTryStatement);
    tryStatements.forEach(tryStmt => {
      if (tryStmt.catchClause && tryStmt.catchClause.block.statements.length === 0) {
        const { line, column } = this.getNodePosition(sourceFile, tryStmt.catchClause);
        violations.push({
          type: 'error',
          file: filePath,
          line,
          column,
          message: 'Empty catch block detected',
          rule: 'no-empty-catch',
          category: 'maintainability',
          severity: 3
        });
      }
    });
  }

  /**
   * 辅助方法：查找特定类型的节点
   */
  private findNodesOfType<T extends ts.Node>(
    node: ts.Node,
    predicate: (node: ts.Node) => node is T
  ): T[] {
    const results: T[] = [];
    
    const visit = (child: ts.Node) => {
      if (predicate(child)) {
        results.push(child);
      }
      ts.forEachChild(child, visit);
    };
    
    visit(node);
    return results;
  }

  /**
   * 辅助方法：获取节点位置
   */
  private getNodePosition(sourceFile: ts.SourceFile, node: ts.Node): { line: number; column: number } {
    const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
    return { line: line + 1, column: character + 1 };
  }
}

/**
 * 代码审查范围
 * Code review scope
 */
export enum ReviewScope {
  COMPREHENSIVE = "comprehensive",
  DIAGNOSTIC = "diagnostic",
  SECURITY_ONLY = "security_only",
  QUALITY_ONLY = "quality_only"
}

/**
 * 文件清理模式
 * File cleanup mode
 */
export enum CleanupMode {
  SAFE = "safe",
  AGGRESSIVE = "aggressive",
  ANALYSIS_ONLY = "analysis_only"
}

/**
 * 质量检查结果
 * Quality check result
 */
export interface QualityCheckResult {
  category: string;
  status: 'PASS' | 'FAIL' | 'WARNING';
  message: string;
  details?: string[];
  suggestions?: string[];
}

/**
 * 文件清理结果
 * File cleanup result
 */
export interface CleanupResult {
  filesAnalyzed: number;
  filesRemoved: number;
  directoriesOptimized: number;
  removedFiles: string[];
  warnings: string[];
  suggestions: string[];
}

/**
 * 综合质量检查工具的输出结果
 * Comprehensive quality check tool output result
 */
export interface CodeReviewAndCleanupResult {
  taskId: string;
  overallScore: number;
  qualityChecks: QualityCheckResult[];
  cleanupResults: CleanupResult;
  auditCheckpoints: AuditCheckpoint[];
  nextSteps: string[];
  workflowContinuation: {
    shouldProceed: boolean;
    nextTool?: string;
    nextToolParams?: Record<string, any>;
  };
}/**
 * 代码审查和清理工具的参数验证schema
 * Code review and cleanup tool parameter validation schema
 */
export const codeReviewAndCleanupSchema = z.object({
  project: z
    .string()
    .min(1, {
      message: "Project parameter is required for multi-agent safety. Please specify the project name to ensure data isolation and prevent concurrent conflicts.",
    })
    .describe("REQUIRED - Target project context for code review and cleanup. MANDATORY for multi-agent concurrent safety. Ensures operations are performed in correct project context and prevents data conflicts between different agents. EXAMPLES: 'my-web-app', 'backend-api', 'mobile-client'. CRITICAL: This parameter prevents concurrent agent conflicts in both MCPHub gateway mode and single IDE mode."),
  taskId: z
    .string()
    .regex(UUID_V4_REGEX, {
      message: "Invalid task ID format. Must be a valid UUID v4 format (8-4-4-4-12 hexadecimal digits). EXAMPLE: 'a1b2c3d4-e5f6-4789-a012-b3c4d5e6f789'. Use list_tasks or query_task to find valid task IDs.",
    })
    .describe("Unique identifier of the task to review and cleanup. MUST BE: valid UUID v4 format from existing task in system. HOW TO GET: use list_tasks to see all tasks, or query_task to search by name/description. EXAMPLE: 'a1b2c3d4-e5f6-4789-a012-b3c4d5e6f789'. VALIDATION: 8-4-4-4-12 hexadecimal pattern."),
  reviewScope: z
    .nativeEnum(ReviewScope)
    .default(ReviewScope.COMPREHENSIVE)
    .describe("Scope of code review to perform. COMPREHENSIVE: Full quality, security, and cleanup analysis. DIAGNOSTIC: Focus on identifying specific issues. SECURITY_ONLY: Security vulnerabilities only. QUALITY_ONLY: Code quality standards only."),
  cleanupMode: z
    .nativeEnum(CleanupMode)
    .default(CleanupMode.SAFE)
    .describe("File cleanup mode. SAFE: Conservative cleanup of obvious temporary files. AGGRESSIVE: More thorough cleanup including build artifacts. ANALYSIS_ONLY: Analyze cleanup opportunities without making changes."),
  targetFiles: z
    .array(z.string())
    .optional()
    .describe("Optional array of specific files to review. If not provided, reviews all files related to the task."),
});

/**
 * 执行代码质量检查
 * Execute code quality checks
 */
class CodeQualityChecker {
  /**
   * 执行综合代码质量检查
   * Execute comprehensive code quality checks
   */
  static async executeQualityChecks(
    task: Task,
    reviewScope: ReviewScope,
    targetFiles?: string[]
  ): Promise<QualityCheckResult[]> {
    const results: QualityCheckResult[] = [];

    if (reviewScope === ReviewScope.COMPREHENSIVE || reviewScope === ReviewScope.QUALITY_ONLY) {
      // 代码标准检查
      results.push(await this.checkCodeStandards(task, targetFiles));

      // 复杂度分析
      results.push(await this.analyzeComplexity(task, targetFiles));

      // 测试覆盖率检查
      results.push(await this.checkTestCoverage(task, targetFiles));
    }

    if (reviewScope === ReviewScope.COMPREHENSIVE || reviewScope === ReviewScope.SECURITY_ONLY) {
      // 安全漏洞检查
      results.push(await this.checkSecurityVulnerabilities(task, targetFiles));

      // 输入验证检查
      results.push(await this.checkInputValidation(task, targetFiles));
    }

    if (reviewScope === ReviewScope.COMPREHENSIVE || reviewScope === ReviewScope.DIAGNOSTIC) {
      // 错误处理检查
      results.push(await this.checkErrorHandling(task, targetFiles));

      // 性能问题检查
      results.push(await this.checkPerformanceIssues(task, targetFiles));
    }

    return results;
  }  /**
   * 检查代码标准
   * Check code standards
   */
  private static async checkCodeStandards(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      // 使用真实的代码质量检查器 - 消除虚假实现
      // Use real code quality checker - eliminate fake implementations
      const qualityChecker = RealCodeQualityAnalyzer.getInstance();

      // 获取要检查的文件路径 - 修复 targetFiles 处理逻辑
      const filesToCheck: string[] = [];
      
      if (targetFiles && targetFiles.length > 0) {
        // 如果指定了 targetFiles，直接使用这些文件
        for (const filePath of targetFiles) {
          const fullPath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);
          if (fs.existsSync(fullPath)) {
            filesToCheck.push(fullPath);
          }
        }
      } else if (task.relatedFiles) {
        // 否则使用任务的相关文件
        for (const file of task.relatedFiles) {
          const fullPath = path.isAbsolute(file.path) ? file.path : path.resolve(process.cwd(), file.path);
          if (fs.existsSync(fullPath)) {
            filesToCheck.push(fullPath);
          }
        }
      }

      // 调试信息
      console.log('DEBUG: targetFiles:', targetFiles);
      console.log('DEBUG: filesToCheck:', filesToCheck);
      console.log('DEBUG: task.relatedFiles:', task.relatedFiles?.map(f => f.path));

      if (filesToCheck.length === 0) {
        return {
          category: 'Code Standards',
          status: 'FAIL',
          message: `No files to check. targetFiles: ${JSON.stringify(targetFiles)}, task.relatedFiles: ${task.relatedFiles?.length || 0}`,
          details: ['Debug: Check file paths and existence'],
          suggestions: ['Verify file paths are correct and files exist']
        };
      }

      // 使用全新的真实代码质量分析器
      console.log('🔍 [REAL ANALYZER] Starting comprehensive analysis...');
      const { RealCodeQualityAnalyzer } = await import('./realCodeQualityAnalyzer.js');
      const realAnalyzer = RealCodeQualityAnalyzer.getInstance();
      
      const analysisResult = await realAnalyzer.analyzeFiles(filesToCheck);
      
      const errorCount = analysisResult.violations.filter(v => v.type === 'error').length;
      const warningCount = analysisResult.violations.filter(v => v.type === 'warning').length;

      let status: 'PASS' | 'WARNING' | 'FAIL' = 'PASS';
      let message = 'Code standards check passed';
      const details: string[] = [];
      const suggestions: string[] = [];

      if (errorCount > 0) {
        status = 'FAIL';
        message = `❌ REAL ANALYZER: Found ${errorCount} errors and ${warningCount} warnings (Health Score: ${analysisResult.healthScore}/100)`;
        details.push(...analysisResult.violations
          .filter(v => v.type === 'error')
          .slice(0, 10)
          .map(v => `${path.basename(v.file)}:${v.line}:${v.column} - ${v.message} (${v.rule})`));
        suggestions.push(...analysisResult.recommendations);
      } else if (warningCount > 5) {
        status = 'WARNING';
        message = `⚠️ REAL ANALYZER: Found ${warningCount} warnings (Health Score: ${analysisResult.healthScore}/100)`;
        details.push(...analysisResult.violations
          .filter(v => v.type === 'warning')
          .slice(0, 5)
          .map(v => `${path.basename(v.file)}:${v.line}:${v.column} - ${v.message} (${v.rule})`));
        suggestions.push(...analysisResult.recommendations);
      } else {
        message = `✅ REAL ANALYZER: Code standards check passed (Health Score: ${analysisResult.healthScore}/100)`;
      }

      // 添加分析统计信息
      details.push(`Files analyzed: ${analysisResult.summary.filesAnalyzed}`);
      details.push(`Total violations: ${analysisResult.summary.totalViolations}`);
      details.push(`Health score: ${analysisResult.healthScore}/100`);

      return {
        category: 'Code Standards',
        status,
        message,
        details,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Code Standards',
        status: 'FAIL',
        message: `Code standards check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review code standards checking implementation']
      };
    }
  }

  /**
   * 分析代码复杂度
   * Analyze code complexity
   */
  private static async analyzeComplexity(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      // 使用真实的复杂度分析 - 基于 TypeScript AST
      // Use real complexity analysis - based on TypeScript AST
      const qualityChecker = RealCodeQualityAnalyzer.getInstance();

      // 获取要分析的文件路径 - 修复 targetFiles 处理逻辑
      const filesToAnalyze: string[] = [];
      
      if (targetFiles && targetFiles.length > 0) {
        // 如果指定了 targetFiles，直接使用这些文件
        for (const filePath of targetFiles) {
          const fullPath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);
          if (fs.existsSync(fullPath) && fullPath.match(/\.(ts|tsx|js|jsx)$/)) {
            filesToAnalyze.push(fullPath);
          }
        }
      } else if (task.relatedFiles) {
        // 否则使用任务的相关文件
        for (const file of task.relatedFiles) {
          const fullPath = path.isAbsolute(file.path) ? file.path : path.resolve(process.cwd(), file.path);
          if (fs.existsSync(fullPath) && fullPath.match(/\.(ts|tsx|js|jsx)$/)) {
            filesToAnalyze.push(fullPath);
          }
        }
      }

      if (filesToAnalyze.length === 0) {
        return {
          category: 'Code Complexity',
          status: 'PASS',
          message: 'No TypeScript/JavaScript files to analyze',
          details: [],
          suggestions: []
        };
      }

      // 执行真实的复杂度分析
      const complexityAnalysis = await qualityChecker.analyzeCodeQuality(filesToAnalyze);

      let status: 'PASS' | 'WARNING' | 'FAIL' = 'PASS';
      let message = 'Code complexity within acceptable limits';
      const details: string[] = [];
      const suggestions: string[] = [];

      // 检查复杂度违规
      const complexityViolations = complexityAnalysis.violations.filter(v => v.category === 'complexity');
      if (complexityViolations.length > 0) {
        status = 'WARNING';
        details.push(...complexityViolations.slice(0, 5).map(v =>
          `${path.basename(v.file)}:${v.line}:${v.column} - ${v.message}`
        ));
        suggestions.push('Consider breaking down complex functions into smaller ones');
        suggestions.push('Reduce nested conditions and loops');
      }

      // 检查可维护性指数
      const maintainabilityThreshold = 50;
      if (complexityAnalysis.metrics.maintainabilityIndex < maintainabilityThreshold) {
        status = 'FAIL';
        details.push(`Maintainability index: ${complexityAnalysis.metrics.maintainabilityIndex} (threshold: ${maintainabilityThreshold})`);
        suggestions.push('Refactor code to improve maintainability');
      }

      // 添加复杂度指标详情
      details.push(`Average cyclomatic complexity: ${complexityAnalysis.metrics.cyclomaticComplexity.toFixed(1)}`);
      details.push(`Average cognitive complexity: ${complexityAnalysis.metrics.cognitiveComplexity.toFixed(1)}`);
      details.push(`Lines of code: ${complexityAnalysis.metrics.linesOfCode}`);
      details.push(`Classes: ${complexityAnalysis.metrics.classCount}, Methods: ${complexityAnalysis.metrics.methodCount}`);

      if (status !== 'PASS') {
        message = `Code complexity issues detected`;
      }

      return {
        category: 'Code Complexity',
        status,
        message,
        details,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Code Complexity',
        status: 'FAIL',
        message: `Complexity analysis failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review complexity analysis implementation']
      };
    }
  }  /**
   * 检查测试覆盖率
   * Check test coverage
   */
  private static async checkTestCoverage(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        const codeFiles = task.relatedFiles.filter(f =>
          f.type === 'TO_MODIFY' || f.type === 'CREATE'
        );
        const testFiles = task.relatedFiles.filter(f =>
          f.path.includes('test') || f.path.includes('spec')
        );

        if (codeFiles.length > 0 && testFiles.length === 0) {
          issues.push('No test files found for implementation');
          suggestions.push('Add unit tests for new functionality');
        }

        // 检查测试文件的质量
        for (const testFile of testFiles) {
          if (fs.existsSync(testFile.path)) {
            const content = fs.readFileSync(testFile.path, 'utf-8');

            if (!content.includes('expect') && !content.includes('assert')) {
              issues.push(`Test file ${testFile.path} appears to have no assertions`);
              suggestions.push('Add proper test assertions to verify functionality');
            }
          }
        }
      }

      return {
        category: 'Test Coverage',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Test coverage check passed' : `Found ${issues.length} test coverage issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Test Coverage',
        status: 'FAIL',
        message: `Test coverage check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review test coverage checking implementation']
      };
    }
  }

  /**
   * 检查安全漏洞
   * Check security vulnerabilities
   */
  private static async checkSecurityVulnerabilities(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');
            // 安全检查保留，但移除其他与质量无关的字符串规则
            if (content.includes('eval(') || content.includes('Function(')) {
              issues.push(`Dangerous eval() usage found in ${file.path}`);
              suggestions.push('Avoid using eval() or Function() constructor for security reasons');
            }
            // 其余更高级安全检查应由专用安全工具完成，这里不使用简单字符串规则以避免误报
          }
        }
      }

      return {
        category: 'Security',
        status: issues.length === 0 ? 'PASS' : 'FAIL',
        message: issues.length === 0 ? 'Security check passed' : `Found ${issues.length} security issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Security',
        status: 'FAIL',
        message: `Security check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review security checking implementation']
      };
    }
  }  /**
   * 检查输入验证
   * Check input validation
   */
  private static async checkInputValidation(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');

            // 检查是否有输入验证
            if (content.includes('req.body') || content.includes('params') || content.includes('query')) {
              if (!content.includes('validate') && !content.includes('schema') && !content.includes('zod')) {
                issues.push(`Missing input validation in ${file.path}`);
                suggestions.push('Add input validation using Zod or similar validation library');
              }
            }
          }
        }
      }

      return {
        category: 'Input Validation',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Input validation check passed' : `Found ${issues.length} validation issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Input Validation',
        status: 'FAIL',
        message: `Input validation check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review input validation checking implementation']
      };
    }
  }

  /**
   * 检查错误处理
   * Check error handling
   */
  private static async checkErrorHandling(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');

            // 检查异步操作的错误处理
            if (content.includes('await') || content.includes('Promise')) {
              if (!content.includes('try') && !content.includes('catch')) {
                issues.push(`Missing error handling for async operations in ${file.path}`);
                suggestions.push('Add try-catch blocks for async operations');
              }
            }
          }
        }
      }

      return {
        category: 'Error Handling',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Error handling check passed' : `Found ${issues.length} error handling issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Error Handling',
        status: 'FAIL',
        message: `Error handling check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review error handling checking implementation']
      };
    }
  }

  /**
   * 检查性能问题
   * Check performance issues
   */
  private static async checkPerformanceIssues(task: Task, targetFiles?: string[]): Promise<QualityCheckResult> {
    try {
      const issues: string[] = [];
      const suggestions: string[] = [];

      if (task.relatedFiles) {
        for (const file of task.relatedFiles) {
          if (targetFiles && !targetFiles.includes(file.path)) continue;

          if (fs.existsSync(file.path)) {
            const content = fs.readFileSync(file.path, 'utf-8');

            // 检查潜在的性能问题
            if (content.includes('for') && content.includes('for')) {
              const nestedLoops = (content.match(/for\s*\(/g) || []).length;
              if (nestedLoops > 2) {
                issues.push(`Potential performance issue: nested loops in ${file.path}`);
                suggestions.push('Consider optimizing nested loops or using more efficient algorithms');
              }
            }
          }
        }
      }

      return {
        category: 'Performance',
        status: issues.length === 0 ? 'PASS' : 'WARNING',
        message: issues.length === 0 ? 'Performance check passed' : `Found ${issues.length} performance issues`,
        details: issues,
        suggestions
      };
    } catch (error) {
      return {
        category: 'Performance',
        status: 'FAIL',
        message: `Performance check failed: ${error instanceof Error ? error.message : String(error)}`,
        suggestions: ['Review performance checking implementation']
      };
    }
  }
}/**
 * 文件清理管理器
 * File cleanup manager
 */
class FileCleanupManager {
  /**
   * 执行文件清理
   * Execute file cleanup
   */
  static async executeCleanup(
    task: Task,
    cleanupMode: CleanupMode,
    projectPath: string
  ): Promise<CleanupResult> {
    const result: CleanupResult = {
      filesAnalyzed: 0,
      filesRemoved: 0,
      directoriesOptimized: 0,
      removedFiles: [],
      warnings: [],
      suggestions: []
    };

    try {
      // 分析项目目录
      await this.analyzeProjectStructure(projectPath, result);

      if (cleanupMode !== CleanupMode.ANALYSIS_ONLY) {
        // 清理临时文件
        await this.cleanupTemporaryFiles(projectPath, cleanupMode, result);

        // 清理测试文件
        await this.cleanupTestFiles(projectPath, cleanupMode, result);

        // 优化目录结构
        await this.optimizeDirectoryStructure(projectPath, cleanupMode, result);
      }

      // 生成建议
      this.generateCleanupSuggestions(result);

    } catch (error) {
      result.warnings.push(`Cleanup operation failed: ${error instanceof Error ? error.message : String(error)}`);
    }

    return result;
  }

  /**
   * 分析项目结构
   * Analyze project structure
   */
  private static async analyzeProjectStructure(projectPath: string, result: CleanupResult): Promise<void> {
    try {
      const analyzeDirectory = (dirPath: string) => {
        if (!fs.existsSync(dirPath)) return;

        const items = fs.readdirSync(dirPath);
        for (const item of items) {
          const itemPath = path.join(dirPath, item);
          const stat = fs.statSync(itemPath);

          if (stat.isFile()) {
            result.filesAnalyzed++;

            // 识别可能需要清理的文件
            if (this.isTemporaryFile(item)) {
              result.suggestions.push(`Consider removing temporary file: ${itemPath}`);
            }
          } else if (stat.isDirectory() && !this.isSystemDirectory(item)) {
            analyzeDirectory(itemPath);
          }
        }
      };

      analyzeDirectory(projectPath);
    } catch (error) {
      result.warnings.push(`Failed to analyze project structure: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * 清理临时文件
   * Cleanup temporary files
   */
  private static async cleanupTemporaryFiles(
    projectPath: string,
    cleanupMode: CleanupMode,
    result: CleanupResult
  ): Promise<void> {
    const tempPatterns = [
      /\.tmp$/,
      /\.temp$/,
      /~$/,
      /\.bak$/,
      /\.swp$/,
      /\.log$/
    ];

    if (cleanupMode === CleanupMode.AGGRESSIVE) {
      tempPatterns.push(
        /node_modules/,
        /\.cache/,
        /dist/,
        /build/
      );
    }

    const cleanupDirectory = async (dirPath: string) => {
      if (!fs.existsSync(dirPath)) return;

      const items = fs.readdirSync(dirPath);
      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const stat = fs.statSync(itemPath);

        if (stat.isFile()) {
          const shouldRemove = tempPatterns.some(pattern => pattern.test(item));
          if (shouldRemove) {
            try {
              await withFileLock(itemPath, async () => {
                fs.unlinkSync(itemPath);
                result.filesRemoved++;
                result.removedFiles.push(itemPath);
              });
            } catch (error) {
              result.warnings.push(`Failed to remove ${itemPath}: ${error instanceof Error ? error.message : String(error)}`);
            }
          }
        } else if (stat.isDirectory() && !this.isSystemDirectory(item)) {
          await cleanupDirectory(itemPath);
        }
      }
    };

    await cleanupDirectory(projectPath);
  }  /**
   * 清理测试文件
   * Cleanup test files
   */
  private static async cleanupTestFiles(
    projectPath: string,
    cleanupMode: CleanupMode,
    result: CleanupResult
  ): Promise<void> {
    // 只在安全模式下清理明显的测试临时文件
    if (cleanupMode === CleanupMode.SAFE) {
      const testTempPatterns = [
        /test.*\.tmp$/,
        /spec.*\.tmp$/,
        /\.test\.log$/,
        /coverage.*\.tmp$/
      ];

      const cleanupTestDirectory = async (dirPath: string) => {
        if (!fs.existsSync(dirPath)) return;

        const items = fs.readdirSync(dirPath);
        for (const item of items) {
          const itemPath = path.join(dirPath, item);
          const stat = fs.statSync(itemPath);

          if (stat.isFile()) {
            const shouldRemove = testTempPatterns.some(pattern => pattern.test(item));
            if (shouldRemove) {
              try {
                fs.unlinkSync(itemPath);
                result.filesRemoved++;
                result.removedFiles.push(itemPath);
              } catch (error) {
                result.warnings.push(`Failed to remove test file ${itemPath}: ${error instanceof Error ? error.message : String(error)}`);
              }
            }
          } else if (stat.isDirectory() && (item.includes('test') || item.includes('spec'))) {
            await cleanupTestDirectory(itemPath);
          }
        }
      };

      await cleanupTestDirectory(projectPath);
    }
  }

  /**
   * 优化目录结构
   * Optimize directory structure
   */
  private static async optimizeDirectoryStructure(
    projectPath: string,
    cleanupMode: CleanupMode,
    result: CleanupResult
  ): Promise<void> {
    try {
      // 检查空目录
      const checkEmptyDirectories = (dirPath: string) => {
        if (!fs.existsSync(dirPath)) return;

        const items = fs.readdirSync(dirPath);
        for (const item of items) {
          const itemPath = path.join(dirPath, item);
          const stat = fs.statSync(itemPath);

          if (stat.isDirectory() && !this.isSystemDirectory(item)) {
            checkEmptyDirectories(itemPath);

            // 检查目录是否为空
            const dirItems = fs.readdirSync(itemPath);
            if (dirItems.length === 0) {
              try {
                fs.rmdirSync(itemPath);
                result.directoriesOptimized++;
                result.suggestions.push(`Removed empty directory: ${itemPath}`);
              } catch (error) {
                result.warnings.push(`Failed to remove empty directory ${itemPath}: ${error instanceof Error ? error.message : String(error)}`);
              }
            }
          }
        }
      };

      checkEmptyDirectories(projectPath);
    } catch (error) {
      result.warnings.push(`Directory optimization failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * 生成清理建议
   * Generate cleanup suggestions
   */
  private static generateCleanupSuggestions(result: CleanupResult): void {
    if (result.filesRemoved === 0) {
      result.suggestions.push('Project appears to be clean - no temporary files found');
    } else {
      result.suggestions.push(`Successfully cleaned ${result.filesRemoved} temporary files`);
    }

    if (result.directoriesOptimized > 0) {
      result.suggestions.push(`Optimized ${result.directoriesOptimized} directories`);
    }

    result.suggestions.push('Consider running cleanup regularly to maintain project hygiene');
  }

  /**
   * 检查是否为临时文件
   * Check if file is temporary
   */
  private static isTemporaryFile(filename: string): boolean {
    const tempPatterns = [
      /\.tmp$/,
      /\.temp$/,
      /~$/,
      /\.bak$/,
      /\.swp$/,
      /\.log$/,
      /\.cache$/
    ];

    return tempPatterns.some(pattern => pattern.test(filename));
  }

  /**
   * 检查是否为系统目录
   * Check if directory is system directory
   */
  private static isSystemDirectory(dirname: string): boolean {
    const systemDirs = [
      '.git',
      '.vscode',
      '.idea',
      'node_modules',
      '.next',
      '.nuxt',
      'dist',
      'build'
    ];

    return systemDirs.includes(dirname);
  }
}/**
 * 代码审查和清理工具主函数
 * Code review and cleanup tool main function
 */
export async function codeReviewAndCleanupTool({
  project,
  taskId,
  reviewScope,
  cleanupMode,
  targetFiles,
}: z.infer<typeof codeReviewAndCleanupSchema>) {
  const { ProjectSession } = await import("../../utils/projectSession.js");

  return await ProjectSession.withProjectContext(project, async () => {
    try {
      // 获取任务信息
      const task = await getTaskById(taskId, project);
      if (!task) {
        return createNotFoundError(
          "Task",
          taskId,
          "Use list_tasks to see all available tasks, or query_task to search by name/description"
        );
      }

      // 执行代码质量检查
      const qualityChecks = await CodeQualityChecker.executeQualityChecks(
        task,
        reviewScope,
        targetFiles
      );

      // 获取项目路径
      const projectPath = process.cwd(); // 简化实现，实际应该从项目配置获取

      // 执行文件清理
      const cleanupResults = await FileCleanupManager.executeCleanup(
        task,
        cleanupMode,
        projectPath
      );

      // 生成审计检查点
      const auditCheckpoints = generateAuditCheckpoints(task, qualityChecks);

      // 计算总体评分
      const overallScore = calculateOverallScore(qualityChecks);

      // 生成下一步建议
      const nextSteps = generateNextSteps(qualityChecks, cleanupResults, overallScore);

      // 查找或创建工作流上下文
      let workflow = SimpleWorkflowManager.findWorkflowByTaskId(taskId);
      if (!workflow) {
        // 创建标准的任务验证工作流
        workflow = SimpleWorkflowManager.createWorkflow(
          taskId,
          project,
          ["verify_task", "code_review_and_cleanup_tool", "execute_task"]
        );
      }

      // 更新当前步骤状态
      const currentStepIndex = workflow.steps.findIndex(s => s.tool === "code_review_and_cleanup_tool");
      if (currentStepIndex >= 0) {
        SimpleWorkflowManager.updateStepStatus(
          workflow.workflowId,
          currentStepIndex,
          overallScore >= 80 ? WorkflowStatus.COMPLETED : WorkflowStatus.FAILED,
          { overallScore, qualityChecks, cleanupResults },
          overallScore < 80 ? "Quality standards not met" : undefined
        );
      }

      // 生成工作流继续指导
      const workflowContinuation = SimpleWorkflowManager.generateContinuation(workflow.workflowId);

      const result: CodeReviewAndCleanupResult = {
        taskId,
        overallScore,
        qualityChecks,
        cleanupResults,
        auditCheckpoints,
        nextSteps,
        workflowContinuation
      };

      // 生成结构化的响应提示词
      const responsePrompt = generateResponsePrompt(result);

      // 使用工作流感知的响应格式
      return createWorkflowResponse(responsePrompt, workflowContinuation);

    } catch (error) {
      return createInternalError(
        "Code review and cleanup",
        error instanceof Error ? error : new Error(String(error))
      );
    }
  });
}

/**
 * 生成审计检查点
 * Generate audit checkpoints
 */
function generateAuditCheckpoints(task: Task, qualityChecks: QualityCheckResult[]): AuditCheckpoint[] {
  const checkpoints: AuditCheckpoint[] = [];

  // 基于质量检查结果生成检查点
  qualityChecks.forEach(check => {
    if (check.status === 'FAIL') {
      checkpoints.push({
        name: `${check.category} Review`,
        description: check.message,
        mandatory: true,
        timing: 'BEFORE_COMPLETION',
        criteria: check.details || [],
        tools: ['code-review', 'static-analysis']
      });
    }
  });

  // 添加通用安全检查点
  checkpoints.push({
    name: 'Security Review',
    description: 'Comprehensive security vulnerability assessment',
    mandatory: true,
    timing: 'BEFORE_COMPLETION',
    criteria: ['No security vulnerabilities', 'Input validation present', 'Access controls proper'],
    tools: ['security-scan', 'vulnerability-check', 'access-review']
  });

  return checkpoints;
}

/**
 * 计算总体评分
 * Calculate overall score
 */
function calculateOverallScore(qualityChecks: QualityCheckResult[]): number {
  if (qualityChecks.length === 0) return 100;

  // 基于类别的加权评分，避免“PASS=100/FAIL=30”简化
  const weights: Record<string, number> = {
    'Code Standards': 0.25,      // ESLint 错误和警告
    'Code Complexity': 0.30,     // 循环复杂度和认知复杂度
    'Test Coverage': 0.20,       // 实际测试覆盖率
    'Security': 0.15,            // 安全漏洞检测
    'Maintainability': 0.10,     // 可维护性指数
  };

  let score = 0;
  let totalWeight = 0;

  for (const check of qualityChecks) {
    const w = weights[check.category] ?? 0.05;
    totalWeight += w;
    // 基于真实数值计算评分，消除虚假的 PASS=100/WARNING=70/FAIL=30 评分
    let categoryScore = 100;

    if (check.details && check.details.length > 0) {
      // 根据问题数量和严重程度计算真实评分
      const issueCount = check.details.length;
      const severity = check.status === 'FAIL' ? 3 : check.status === 'WARNING' ? 2 : 1;

      // 使用指数衰减函数计算评分，避免线性惩罚
      categoryScore = Math.max(0, 100 * Math.exp(-0.1 * issueCount * severity));
    }

    score += categoryScore * w;
  }

  if (totalWeight === 0) return 100;
  return Math.round(score / totalWeight);
}/**
 * 生成下一步建议
 * Generate next steps
 */
function generateNextSteps(
  qualityChecks: QualityCheckResult[],
  cleanupResults: CleanupResult,
  overallScore: number
): string[] {
  const steps: string[] = [];

  // 基于质量检查结果生成建议
  qualityChecks.forEach(check => {
    if (check.status === 'FAIL' && check.suggestions) {
      steps.push(...check.suggestions);
    }
  });

  // 基于清理结果生成建议
  if (cleanupResults.suggestions) {
    steps.push(...cleanupResults.suggestions);
  }

  // 基于总体评分生成建议
  if (overallScore >= 80) {
    steps.push('Quality standards met - ready to proceed to next task');
  } else {
    steps.push('Address quality issues before proceeding');
    steps.push('Re-run code review after fixes');
  }

  return steps;
}

/**
 * 确定工作流程继续
 * Determine workflow continuation
 */
function determineWorkflowContinuation(overallScore: number, project: string): {
  shouldProceed: boolean;
  nextTool?: string;
  nextToolParams?: Record<string, any>;
} {
  if (overallScore >= 80) {
    return {
      shouldProceed: true,
      nextTool: 'execute_task',
      nextToolParams: {
        project: project,
        // 下一个任务ID需要从任务列表中获取
      }
    };
  } else {
    return {
      shouldProceed: false
    };
  }
}

/**
 * 生成响应提示词
 * Generate response prompt
 */
function generateResponsePrompt(result: CodeReviewAndCleanupResult): string {
  let prompt = `## 🔍 Code Review and Cleanup Results\n\n`;

  prompt += `**Task ID:** ${result.taskId}\n`;
  prompt += `**Overall Quality Score:** ${result.overallScore}/100\n\n`;

  // 质量检查结果
  prompt += `### Quality Check Results\n\n`;
  result.qualityChecks.forEach(check => {
    const statusIcon = check.status === 'PASS' ? '✅' : check.status === 'WARNING' ? '⚠️' : '❌';
    prompt += `${statusIcon} **${check.category}**: ${check.message}\n`;

    if (check.details && check.details.length > 0) {
      prompt += `   - Issues: ${check.details.join(', ')}\n`;
    }

    if (check.suggestions && check.suggestions.length > 0) {
      prompt += `   - Suggestions: ${check.suggestions.join(', ')}\n`;
    }
    prompt += `\n`;
  });

  // 清理结果
  prompt += `### File Cleanup Results\n\n`;
  prompt += `- Files Analyzed: ${result.cleanupResults.filesAnalyzed}\n`;
  prompt += `- Files Removed: ${result.cleanupResults.filesRemoved}\n`;
  prompt += `- Directories Optimized: ${result.cleanupResults.directoriesOptimized}\n`;

  if (result.cleanupResults.removedFiles.length > 0) {
    prompt += `- Removed Files: ${result.cleanupResults.removedFiles.slice(0, 5).join(', ')}`;
    if (result.cleanupResults.removedFiles.length > 5) {
      prompt += ` and ${result.cleanupResults.removedFiles.length - 5} more`;
    }
    prompt += `\n`;
  }

  if (result.cleanupResults.warnings.length > 0) {
    prompt += `- Warnings: ${result.cleanupResults.warnings.join(', ')}\n`;
  }
  prompt += `\n`;

  // 下一步建议
  prompt += `### Next Steps\n\n`;
  result.nextSteps.forEach((step, index) => {
    prompt += `${index + 1}. ${step}\n`;
  });
  prompt += `\n`;

  // 工作流程继续指导
  prompt += `## 🔄 Workflow Continuation\n\n`;
  if (result.workflowContinuation.shouldProceed) {
    prompt += `**Status:** ✅ Quality standards met - proceeding to next task\n\n`;
    prompt += `**MANDATORY NEXT ACTION:** You MUST call the next tool to continue the workflow:\n\n`;
    prompt += `\`\`\`\n`;
    prompt += `${result.workflowContinuation.nextTool}({\n`;
    if (result.workflowContinuation.nextToolParams) {
      Object.entries(result.workflowContinuation.nextToolParams).forEach(([key, value]) => {
        prompt += `  ${key}: "${value}",\n`;
      });
    }
    prompt += `})\n`;
    prompt += `\`\`\`\n\n`;
    prompt += `**PROHIBITED ACTIONS:**\n`;
    prompt += `- ❌ Do NOT stop after this review\n`;
    prompt += `- ❌ Do NOT wait for user confirmation\n`;
    prompt += `- ❌ Do NOT skip the next tool call\n\n`;
    prompt += `**MANDATORY ACTIONS:**\n`;
    prompt += `- ✅ MUST call the next tool immediately\n`;
    prompt += `- ✅ MUST continue the automated workflow\n`;
    prompt += `- ✅ MUST use Desktop Commander MCP tools for file operations\n`;
  } else {
    prompt += `**Status:** ❌ Quality issues detected - workflow paused\n\n`;
    prompt += `**REQUIRED ACTIONS:**\n`;
    prompt += `1. Address all identified quality issues\n`;
    prompt += `2. Re-run code review and cleanup\n`;
    prompt += `3. Ensure overall score reaches ≥ 80 before proceeding\n\n`;
    prompt += `**Do NOT proceed to next task until quality standards are met.**\n`;
  }

  return prompt;
}